within NHES.Systems.Examples;
package FMIs
  extends Modelica.Icons.BasesPackage;

  model BOP_ME_fmu
  extends fmuIcon;
  // Model automatically generated by Dymola from FMI model description
  public
    type Modelica_Blocks_Interfaces_BooleanInput = Boolean;
    type Modelica_Blocks_Interfaces_BooleanOutput = Boolean;
    type Modelica_Blocks_Interfaces_RealInput = Real;
    type Modelica_Blocks_Interfaces_RealOutput = Real;
    type TRANSFORM_Units_HydraulicResistance = Real (unit = "Pa/(kg/s)", quantity = "HydraulicResistance");
    type TRANSFORM_Units_NonDim = Real (quantity = "nonDim");
    type TRANSFORM_Types_Dynamics = enumeration(
        DynamicFreeInitial                                         "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
          "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",
        SteadyState "SteadyState -- Steady state balance, Initial guess value");

    type TRANSFORM_Types_Reset = enumeration(
        Disabled                                      "Disabled",
        Parameter "Use parameter value",
        Input "Use input signal");
  protected
    record 'system_rec'
      parameter Modelica.Units.SI.AbsolutePressure p_ambient=101325
        "Default ambient pressure";
      parameter Modelica.Units.SI.Temperature T_ambient=293.15
        "Default ambient temperature";
      parameter Modelica.Units.SI.Acceleration g=9.80665
        "Constant gravity acceleration";
      constant Boolean allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
      constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
      constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of mass balances";
      constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of substance balances";
      constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of trace substance balances";
      constant Modelica.Fluid.Types.Dynamics momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
      parameter Modelica.Units.SI.MassFlowRate m_flow_start=0
        "Default start value for mass flow rates";
      Modelica.Units.SI.AbsolutePressure p_start
        "Default start value for pressures";
      Modelica.Units.SI.Temperature T_start
        "Default start value for temperatures";
      constant Boolean use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
      Modelica.Units.SI.MassFlowRate m_flow_nominal
        "Default nominal mass flow rate";
      parameter Real eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
      parameter Modelica.Units.SI.AbsolutePressure dp_small=1
        "Default small pressure drop for regularization of laminar and zero flow";
      parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0.0) = 0.01
        "Default small mass flow rate for regularization of laminar and zero flow";
    end 'system_rec';
  public
    'system_rec' 'system' annotation(Dialog);
  protected
    record BOP_rec
      constant Integer nPorts_a3 = 1 "Number of port_a3 connections";
      constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
      constant Modelica.Units.SI.Pressure 'port_a3_nominal_p[1]'=1000000.0;
      Modelica.Units.SI.Temperature 'port_a3_nominal_T[1]';
      Modelica.Units.SI.SpecificEnthalpy 'port_a3_nominal_h[1]';
      parameter Modelica.Units.SI.MassFlowRate 'port_a3_nominal_m_flow[1]'=0;
      constant Modelica.Units.SI.Pressure 'port_a3_start_p[1]'=1000000.0;
      Modelica.Units.SI.Temperature 'port_a3_start_T[1]';
      Modelica.Units.SI.SpecificEnthalpy 'port_a3_start_h[1]';
      Modelica.Units.SI.MassFlowRate 'port_a3_start_m_flow[1]';
      parameter Modelica.Units.SI.Pressure p_condenser=10000.0
        "Condenser operating pressure";
      constant Modelica.Units.SI.Pressure p_reservoir=1000000.0
        "Reservoir operating pressure";
    protected
      record CS_rec
        parameter Modelica.Units.SI.Time delayStartTCV=20
          "Delay start of TCV control";
        Modelica.Units.SI.Time delayStartBV "Delay start of BV control";
        parameter Modelica.Units.SI.Pressure p_nominal=3447400 "Steam Pressure";
        parameter Real TCV_opening_nominal = 0.5 "Nominal opening of TCV - controls power";
        parameter Real BV_opening_nominal = 0.001 "Nominal opening of BV - controls pressure";
        Modelica.Units.SI.Power W_totalSetpoint "Total setpoint power from BOP";
      protected
        record actuatorBus_rec
          Real opening_TCV "TCV fraction open";
          Real opening_BV "BV fraction open";
        end actuatorBus_rec;
      public
        actuatorBus_rec actuatorBus;
      protected
        record sensorBus_rec
          constant Modelica.Units.SI.Power Q_balance=0.0
            "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
          constant Modelica.Units.SI.Power W_balance=0.0
            "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
          Modelica.Units.SI.Power W_total "Total electrical power generated";
          Modelica.Units.SI.Pressure p_inlet_steamTurbine
            "Inlet pressure to steam turbine";
        end sensorBus_rec;
      public
        sensorBus_rec sensorBus;
      protected
        record TCV_openingNominal_rec
          Real k "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end TCV_openingNominal_rec;
      public
        TCV_openingNominal_rec TCV_openingNominal;
      protected
        record switch_BV_rec
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end switch_BV_rec;
      public
        switch_BV_rec switch_BV;
      protected
        record BV_openingNominal_rec
          Real k "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end BV_openingNominal_rec;
      public
        BV_openingNominal_rec BV_openingNominal;
      protected
        record greater5_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "s") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_RealInput u2(unit = "s") "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
        end greater5_rec;
      public
        greater5_rec greater5;
      protected
        record clock_rec
          Modelica_Blocks_Interfaces_RealOutput y(unit = "s") "Connector of Real output signal";
          parameter Real offset(unit = "s") = 0 "Offset of output signal y";
          parameter Modelica.Units.SI.Time startTime=0
            "Output y = offset for time < startTime";
        end clock_rec;
      public
        clock_rec clock annotation(Dialog);
      protected
        record valvedelay_rec
          Real k(unit = "s") "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "s") "Connector of Real output signal";
        end valvedelay_rec;
      public
        valvedelay_rec valvedelay;
      protected
        record PID_TCV_opening_rec
          Modelica_Blocks_Interfaces_RealInput u_s(unit = "Pa") "Connector of setpoint input signal";
          Modelica_Blocks_Interfaces_RealInput u_m(unit = "Pa") "Connector of measurement input signal";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of actuator output signal";
          Real controlError(unit = "Pa") "Control error (set point - measurement)";
          constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
          constant Boolean with_FF = false "enable feed-forward input signal";
          constant Boolean derMeas = true "=true avoid derivative kick";
          parameter Real k = 1 "Controller gain: +/- for direct/reverse acting";
          parameter Modelica.Units.SI.Time Ti(min=1E-60) = 0.5
            "Time constant of Integrator block";
          parameter Modelica.Units.SI.Time Td(min=0.0) = 0.1
            "Time constant of Derivative block";
          parameter Real yb = 0 "Output bias. May improve simulation";
          parameter Real k_s = 2.5E-09 "Setpoint input scaling: k_s*u_s. May improve simulation";
          parameter Real k_m = 2.5E-09 "Measurement input scaling: k_m*u_m. May improve simulation";
          parameter Real k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
          Real yMax "Upper limit of output";
          Real yMin "Lower limit of output";
          parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
          parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
          parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
          parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
          constant Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
            "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
          constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
          parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
          parameter Real y_start = 0 "Initial value of output";
          constant Boolean strict = false "= true, if strict limits with noEvent(..)";
          constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of controller output reset";
          constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
        protected
          record addP_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "Pa") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "Pa") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            Real k1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addP_rec;
        public
          addP_rec addP annotation(Dialog);
        protected
          record P_rec
            parameter Real k = 1 "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end P_rec;
        public
          P_rec P annotation(Dialog);
        protected
          record gainPID_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainPID_rec;
        public
          gainPID_rec gainPID;
        protected
          record addPID_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addPID_rec;
        public
          addPID_rec addPID annotation(Dialog);
        protected
          record limiter_rec
            Real uMax "Upper limits of input signals";
            Real uMin "Lower limits of input signals";
            constant Boolean strict = false "= true, if strict limits with noEvent(..)";
            constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
            constant Boolean limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
            Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end limiter_rec;
        public
          limiter_rec limiter;
        protected
          record Fzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Fzero_rec;
        public
          Fzero_rec Fzero annotation(Dialog);
        protected
          record addFF_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addFF_rec;
        public
          addFF_rec addFF annotation(Dialog);
        protected
          record gain_u_s_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "Pa") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "Pa") "Output signal connector";
          end gain_u_s_rec;
        public
          gain_u_s_rec gain_u_s;
        protected
          record gain_u_m_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "Pa") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "Pa") "Output signal connector";
          end gain_u_m_rec;
        public
          gain_u_m_rec gain_u_m;
        protected
          record null_bias_rec
            Real k "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end null_bias_rec;
        public
          null_bias_rec null_bias;
        protected
          record I_rec
            Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y(fixed=false) "Connector of Real output signal";
            Real k "Integrator gain";
            constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
            constant Real y_start = 0.0 "Initial or guess value of output (= state)";
            constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of integrator reset";
            constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
          end I_rec;
        public
          I_rec I;
        protected
          record addI_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1(unit = "Pa") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "Pa") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addI_rec;
        public
          addI_rec addI annotation(Dialog);
        protected
          record addSat_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addSat_rec;
        public
          addSat_rec addSat annotation(Dialog);
        protected
          record gainTrack_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainTrack_rec;
        public
          gainTrack_rec gainTrack;
        protected
          record Dzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Dzero_rec;
        public
          Dzero_rec Dzero annotation(Dialog);
        end PID_TCV_opening_rec;
      public
        PID_TCV_opening_rec PID_TCV_opening annotation(Dialog);
      protected
        record switch_P_setpoint_TCV_rec
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          Modelica_Blocks_Interfaces_RealInput u3(unit = "Pa") "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "Pa") "Connector of Real output signal";
        end switch_P_setpoint_TCV_rec;
      public
        switch_P_setpoint_TCV_rec switch_P_setpoint_TCV;
      protected
        record switch_TCV_setpoint_rec
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          Modelica_Blocks_Interfaces_RealInput u3 "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end switch_TCV_setpoint_rec;
      public
        switch_TCV_setpoint_rec switch_TCV_setpoint;
      protected
        record TCV_diffopeningNominal_rec
          parameter Real k = 0 "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end TCV_diffopeningNominal_rec;
      public
        TCV_diffopeningNominal_rec TCV_diffopeningNominal annotation(Dialog);
      protected
        record TCV_opening_rec
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = 1 "Gain of input signal 2";
        end TCV_opening_rec;
      public
        TCV_opening_rec TCV_opening annotation(Dialog);
      protected
        record switch_P_setpoint_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_BooleanInput u2 "Connector of Boolean input signal";
          Modelica_Blocks_Interfaces_RealInput u3(unit = "W") "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Connector of Real output signal";
        end switch_P_setpoint_rec;
      public
        switch_P_setpoint_rec switch_P_setpoint;
      protected
        record valvedelayBV_rec
          Real k(unit = "s") "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "s") "Connector of Real output signal";
        end valvedelayBV_rec;
      public
        valvedelayBV_rec valvedelayBV;
      protected
        record greater1_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "s") "Connector of first Real input signal";
          Modelica_Blocks_Interfaces_RealInput u2(unit = "s") "Connector of second Real input signal";
          Modelica_Blocks_Interfaces_BooleanOutput y "Connector of Boolean output signal";
        end greater1_rec;
      public
        greater1_rec greater1;
      protected
        record PID_BV_opening_rec
          Modelica_Blocks_Interfaces_RealInput u_s(unit = "W") "Connector of setpoint input signal";
          Modelica_Blocks_Interfaces_RealInput u_m(unit = "W") "Connector of measurement input signal";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of actuator output signal";
          Real controlError(unit = "W") "Control error (set point - measurement)";
          constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
          constant Boolean with_FF = false "enable feed-forward input signal";
          constant Boolean derMeas = true "=true avoid derivative kick";
          parameter Real k = -1 "Controller gain: +/- for direct/reverse acting";
          parameter Modelica.Units.SI.Time Ti(min=1E-60) = 10
            "Time constant of Integrator block";
          parameter Modelica.Units.SI.Time Td(min=0.0) = 0.1
            "Time constant of Derivative block";
          parameter Real yb = 0 "Output bias. May improve simulation";
          parameter Real k_s = 5E-10 "Setpoint input scaling: k_s*u_s. May improve simulation";
          parameter Real k_m = 5E-10 "Measurement input scaling: k_m*u_m. May improve simulation";
          parameter Real k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
          Real yMax "Upper limit of output";
          Real yMin "Lower limit of output";
          parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
          parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
          parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
          parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
          constant Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
            "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
          constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
          parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
          parameter Real y_start = 0 "Initial value of output";
          constant Boolean strict = false "= true, if strict limits with noEvent(..)";
          constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of controller output reset";
          constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
        protected
          record addP_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "W") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "W") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            Real k1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addP_rec;
        public
          addP_rec addP annotation(Dialog);
        protected
          record P_rec
            parameter Real k = 1 "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end P_rec;
        public
          P_rec P annotation(Dialog);
        protected
          record gainPID_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainPID_rec;
        public
          gainPID_rec gainPID;
        protected
          record addPID_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addPID_rec;
        public
          addPID_rec addPID annotation(Dialog);
        protected
          record limiter_rec
            Real uMax "Upper limits of input signals";
            Real uMin "Lower limits of input signals";
            constant Boolean strict = false "= true, if strict limits with noEvent(..)";
            constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
            constant Boolean limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
            Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end limiter_rec;
        public
          limiter_rec limiter;
        protected
          record Fzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Fzero_rec;
        public
          Fzero_rec Fzero annotation(Dialog);
        protected
          record addFF_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addFF_rec;
        public
          addFF_rec addFF annotation(Dialog);
        protected
          record gain_u_s_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "W") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Output signal connector";
          end gain_u_s_rec;
        public
          gain_u_s_rec gain_u_s;
        protected
          record gain_u_m_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "W") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Output signal connector";
          end gain_u_m_rec;
        public
          gain_u_m_rec gain_u_m;
        protected
          record null_bias_rec
            Real k "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end null_bias_rec;
        public
          null_bias_rec null_bias;
        protected
          record I_rec
            Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y(fixed=false) "Connector of Real output signal";
            Real k "Integrator gain";
            constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
            constant Real y_start = 0.0 "Initial or guess value of output (= state)";
            constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of integrator reset";
            constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
          end I_rec;
        public
          I_rec I;
        protected
          record addI_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1(unit = "W") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "W") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addI_rec;
        public
          addI_rec addI annotation(Dialog);
        protected
          record addSat_rec
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addSat_rec;
        public
          addSat_rec addSat annotation(Dialog);
        protected
          record gainTrack_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainTrack_rec;
        public
          gainTrack_rec gainTrack;
        protected
          record Dzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Dzero_rec;
        public
          Dzero_rec Dzero annotation(Dialog);
        end PID_BV_opening_rec;
      public
        PID_BV_opening_rec PID_BV_opening annotation(Dialog);
      protected
        record BV_opening_rec
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = 1 "Gain of input signal 2";
        end BV_opening_rec;
      public
        BV_opening_rec BV_opening annotation(Dialog);
      protected
        record BV_diffopeningNominal_rec
          parameter Real k = 0 "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end BV_diffopeningNominal_rec;
      public
        BV_diffopeningNominal_rec BV_diffopeningNominal annotation(Dialog);
      protected
        record Power_Nominal_rec
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Value of Real output";
        end Power_Nominal_rec;
      public
        Power_Nominal_rec Power_Nominal;
      protected
        record p_Nominal1_rec
          Real k(unit = "Pa") "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "Pa") "Connector of Real output signal";
        end p_Nominal1_rec;
      public
        p_Nominal1_rec p_Nominal1;
      end CS_rec;
    public
      CS_rec CS annotation(Dialog);
    protected
      record ED_rec
      protected
        record actuatorBus_rec
          Real opening_TCV "TCV fraction open";
          Real opening_BV "BV fraction open";
        end actuatorBus_rec;
      public
        actuatorBus_rec actuatorBus;
      protected
        record sensorBus_rec
          constant Modelica.Units.SI.Power Q_balance=0.0
            "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
          constant Modelica.Units.SI.Power W_balance=0.0
            "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
          Modelica.Units.SI.Power W_total "Total electrical power generated";
          Modelica.Units.SI.Pressure p_inlet_steamTurbine
            "Inlet pressure to steam turbine";
        end sensorBus_rec;
      public
        sensorBus_rec sensorBus;
      end ED_rec;
    public
      ED_rec ED;
    protected
      record actuatorBus_rec
        Real opening_TCV(min = 0.0, max = 1.0) "TCV fraction open";
        Real opening_BV(min = 0.0, max = 1.0) "BV fraction open";
      end actuatorBus_rec;
    public
      actuatorBus_rec actuatorBus;
    protected
      record sensorBus_rec
        constant Modelica.Units.SI.Power Q_balance=0.0
          "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
        constant Modelica.Units.SI.Power W_balance=0.0
          "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
        Modelica.Units.SI.Power W_total "Total electrical power generated";
        Modelica.Units.SI.Pressure p_inlet_steamTurbine(
          nominal=1000000.0,
          min=611.657,
          max=100000000.0) "Inlet pressure to steam turbine";
      end sensorBus_rec;
    public
      sensorBus_rec sensorBus;
    protected
      record Q_balance_rec
        constant Modelica_Blocks_Interfaces_RealOutput y(unit = "W") = 0.0 "Value of Real output";
      end Q_balance_rec;
    public
      Q_balance_rec Q_balance;
    protected
      record W_balance_rec
        constant Modelica_Blocks_Interfaces_RealOutput y(unit = "W") = 0.0 "Value of Real output";
      end W_balance_rec;
    public
      W_balance_rec W_balance;
    protected
      record port_a_nominal_rec
        parameter Modelica.Units.SI.Pressure p=3470000 "Absolute pressure";
        Modelica.Units.SI.Temperature T "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
        parameter Modelica.Units.SI.MassFlowRate m_flow=67 "Mass flow rate";
      end port_a_nominal_rec;
    public
      port_a_nominal_rec port_a_nominal annotation(Dialog);
    protected
      record port_b_nominal_rec
        constant Modelica.Units.SI.Pressure p=1000000 "Absolute pressure";
        Modelica.Units.SI.Temperature T "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
        Modelica.Units.SI.MassFlowRate m_flow "Mass flow rate";
      end port_b_nominal_rec;
    public
      port_b_nominal_rec port_b_nominal;
    protected
      record port_a_start_rec
        Modelica.Units.SI.Pressure p "Absolute pressure";
        Modelica.Units.SI.Temperature T "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
        Modelica.Units.SI.MassFlowRate m_flow "Mass flow rate";
      end port_a_start_rec;
    public
      port_a_start_rec port_a_start;
    protected
      record port_b_start_rec
        constant Modelica.Units.SI.Pressure p=1000000.0 "Absolute pressure";
        Modelica.Units.SI.Temperature T "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
        Modelica.Units.SI.MassFlowRate m_flow "Mass flow rate";
      end port_b_start_rec;
    public
      port_b_start_rec port_b_start;
    protected
      record port_a_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end port_a_rec;
    public
      port_a_rec port_a;
    protected
      record port_b_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end port_b_rec;
    public
      port_b_rec port_b;
    protected
      record 'port_a3[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end 'port_a3[1]_rec';
    public
      'port_a3[1]_rec' 'port_a3[1]';
    protected
      record portElec_b_rec
        Modelica.Units.SI.Power W "Active power";
        Modelica.Units.SI.Frequency f "Frequency";
      end portElec_b_rec;
    public
      portElec_b_rec portElec_b;
    protected
      record steamTurbine_rec
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
        constant Integer nUnits = 2 "Number of turbine units, e.g., high pressure and low pressure";
        constant TRANSFORM_Types_Dynamics energyDynamics = TRANSFORM_Types_Dynamics.DynamicFreeInitial "=true to use turbine dynamics";
        parameter Modelica.Units.SI.Time 'taus[1]'=1
          "Characteristic time constant of each unit";
        parameter Modelica.Units.SI.Time 'taus[2]'=1
          "Characteristic time constant of each unit";
        constant TRANSFORM_Units_NonDim 'Q_fracs[1]' = 0.5 "Fraction of power provided per unit";
        constant TRANSFORM_Units_NonDim 'Q_fracs[2]' = 0.5 "Fraction of power provided per unit";
        Modelica.Units.SI.Power 'Q_units_start[1]'
          "Initial power output per unit";
        Modelica.Units.SI.Power 'Q_units_start[2]'
          "Initial power output per unit";
        parameter Real eta_mech = 1.0 "Mechanical efficiency";
        Real p_a_start(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure at port a";
        Real p_b_start(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure at port b";
        constant Boolean use_T_start = false "Use T_start if true, otherwise h_start";
        Real T_a_start(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature at port a";
        Real T_b_start(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature at port b";
        Real h_a_start(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy at port a";
        Real h_b_start(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy at port b";
        parameter Real 'X_start[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions m_i/m";
        Real m_flow_start(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate";
        Real p_ratio "p_out/p_in pressure ratio";
        parameter Modelica.Units.SI.Angle _phi_start=0.0
          annotation (Dialog(tab="Initial", group="States"));
        Modelica.Units.SI.Angle phi(start=_phi_start, fixed=true)
          "Shaft rotation angle";
        Modelica.Units.SI.Torque tau "Net torque acting on the turbine";
        Modelica.Units.SI.AngularVelocity omega "Shaft angular velocity";
        Modelica.Units.SI.MassFlowRate m_flow "Mass flow rate";
        Real h_in(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Inlet enthalpy";
        Real h_out(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Outlet enthalpy";
        Real h_is(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Isentropic outlet enthalpy";
        Real p_in(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Inlet pressure";
        Real p_out(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Outlet pressure";
        Modelica.Units.SI.Power Q_mech "Total mechanical power";
        Modelica.Units.SI.Power 'Q_units[1]'(fixed=false)
          "Mechanical power per unit";
        Modelica.Units.SI.Power 'Q_units[2]'(fixed=false)
          "Mechanical power per unit";
        Modelica.Units.SI.Power 'Qbs[1]' "Power balance";
        Modelica.Units.SI.Power 'Qbs[2]' "Power balance";
        Modelica.Units.SI.Efficiency eta_is "Isentropic efficiency";
        constant Modelica.Units.SI.Pressure p_crit=22064000.0
          "Medium critical pressure";
        Modelica.Units.SI.SpecificEnthalpy h_fsat_in
          "Saturated liquid specific enthalpy at inlet";
        Modelica.Units.SI.SpecificEnthalpy h_gsat_in
          "Saturated vapor specific enthalpy  at inlet";
        Modelica.Units.SI.SpecificEnthalpy h_fsat_out
          "Saturated liquid specific enthalpy at outlet";
        Modelica.Units.SI.SpecificEnthalpy h_gsat_out
          "Saturated vapor specific enthalpy  at outlet";
        TRANSFORM_Units_NonDim x_th_in "Inlet thermodynamic quality";
        TRANSFORM_Units_NonDim x_abs_in "Inlet absolute mass quality";
        TRANSFORM_Units_NonDim x_th_out "Outlet thermodynamic quality";
        TRANSFORM_Units_NonDim x_abs_out "Outlet absolute mass quality";
        constant Modelica_Blocks_Interfaces_RealInput partialArc = 1.0;
        parameter Real partialArc_nominal = 1 "Nominal partial arc";
        Modelica.Units.SI.MassFlowRate m_flow_nominal "Nominal mass flowrate";
        constant Boolean use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
        parameter Modelica.Units.SI.Area Kt_constant=0.01
          "Constant coefficient of Stodola's law";
        constant Boolean use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
        Modelica.Units.SI.Pressure p_inlet_nominal "Nominal inlet pressure";
        Modelica.Units.SI.Pressure p_outlet_nominal "Nominal outlet pressure";
        constant Boolean use_T_nominal = false "=true then use temperature for Kt else density";
        Modelica.Units.SI.Temperature T_nominal "Nominal inlet temperature";
        Modelica.Units.SI.Density d_nominal "Nominal inlet density";
        parameter Modelica.Units.SI.Area Kt(fixed=false)
          "Flow area coefficient";
      protected
        record portHP_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end portHP_rec;
      public
        portHP_rec portHP;
      protected
        record portLP_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end portLP_rec;
      public
        portLP_rec portLP;
      protected
        record shaft_a_rec
          Modelica.Units.SI.Angle phi "Absolute rotation angle of flange";
          constant Modelica.Units.SI.Torque tau=0.0 "Cut torque in the flange";
        end shaft_a_rec;
      public
        shaft_a_rec shaft_a;
      protected
        record shaft_b_rec
          Modelica.Units.SI.Angle phi "Absolute rotation angle of flange";
          Modelica.Units.SI.Torque tau "Cut torque in the flange";
        end shaft_b_rec;
      public
        shaft_b_rec shaft_b;
      protected
        record eta_wetSteam_rec
          TRANSFORM_Units_NonDim x_abs_in "Inlet quality";
          TRANSFORM_Units_NonDim x_abs_out "Outlet quality";
          parameter Modelica.Units.SI.Efficiency eta_nominal=0.85
            "Nominal efficiency due to wetness";
          Modelica.Units.SI.Efficiency eta "Turbine efficiency due to wetness";
        end eta_wetSteam_rec;
      public
        eta_wetSteam_rec eta_wetSteam annotation(Dialog);
      protected
        record state_a_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_a_rec;
      public
        state_a_rec state_a;
      protected
        record state_b_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_b_rec;
      public
        state_b_rec state_b;
      protected
        record sat_in_rec
          Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
          Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
        end sat_in_rec;
      public
        sat_in_rec sat_in;
      protected
        record sat_out_rec
          Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
          Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
        end sat_out_rec;
      public
        sat_out_rec sat_out;
      protected
        record bubble_in_rec
          constant Integer phase(min = 0, max = 2) = 1 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end bubble_in_rec;
      public
        bubble_in_rec bubble_in;
      protected
        record dew_in_rec
          constant Integer phase(min = 0, max = 2) = 1 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end dew_in_rec;
      public
        dew_in_rec dew_in;
      protected
        record bubble_out_rec
          constant Integer phase(min = 0, max = 2) = 1 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end bubble_out_rec;
      public
        bubble_out_rec bubble_out;
      protected
        record dew_out_rec
          constant Integer phase(min = 0, max = 2) = 1 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end dew_out_rec;
      public
        dew_out_rec dew_out;
      end steamTurbine_rec;
    public
      steamTurbine_rec steamTurbine annotation(Dialog);
    protected
      record generator1_rec
        parameter Modelica.Units.SI.Efficiency eta=1.0
          "Mechanical to electric power conversion efficiency";
        constant Modelica.Units.SI.MomentOfInertia J=10000.0
          "Moment of inertia";
        parameter Integer nPoles = 2 "Number of electrical poles";
        parameter Modelica.Units.SI.Frequency f_start=60
          "Start value of the electrical frequency";
        constant Modelica.Fluid.Types.Dynamics momentumDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of momentum balances";
        Modelica.Units.SI.Power Q_mech "Mechanical power";
        Modelica.Units.SI.Power Q_elec "Electrical Power";
        constant Modelica.Units.SI.Power Q_loss=0.0 "Inertial power Loss";
        Modelica.Units.SI.Torque tau "Torque at shaft";
        Modelica.Units.SI.AngularVelocity omega_m
          "Angular velocity of the shaft";
        constant Real _omega_m_der(unit = "rad/s2") = 0.0 "der(Angular velocity of the shaft)";
        Modelica.Units.SI.AngularVelocity omega_e
          "Angular velocity of the e.m.f. rotating frame";
        Modelica.Units.NonSI.AngularVelocity_rpm shaft_rpm
          "Shaft rotational speed";
        Modelica.Units.SI.Frequency f "Electrical frequency";
      protected
        record portElec_rec
          Modelica.Units.SI.Power W "Active power";
          Modelica.Units.SI.Frequency f "Frequency";
        end portElec_rec;
      public
        portElec_rec portElec;
      protected
        record shaft_a_rec
          Modelica.Units.SI.Angle phi "Absolute rotation angle of flange";
          Real _phi_der(unit = "rad/s") "der(Absolute rotation angle of flange)";
          Modelica.Units.SI.Torque tau "Cut torque in the flange";
        end shaft_a_rec;
      public
        shaft_a_rec shaft_a;
      end generator1_rec;
    public
      generator1_rec generator1 annotation(Dialog);
    protected
      record sensorW_rec
        parameter Integer precision(min = 0) = 0 "Number of decimals displayed";
        Real var(unit = "W") "Variable to be converted";
        Real y "Icon display";
        Modelica_Blocks_Interfaces_RealOutput W(unit = "W") "Power flowing from port_a to port_b";
      protected
        record port_a_rec
          Modelica.Units.SI.Power W "Active power";
          Modelica.Units.SI.Frequency f "Frequency";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Modelica.Units.SI.Power W "Active power";
          Modelica.Units.SI.Frequency f "Frequency";
        end port_b_rec;
      public
        port_b_rec port_b;
      end sensorW_rec;
    public
      sensorW_rec sensorW annotation(Dialog);
    protected
      record resistance_rec
        Modelica.Units.SI.PressureDifference dp;
        Modelica.Units.SI.MassFlowRate m_flow;
        parameter Boolean showName = true;
        constant TRANSFORM_Units_HydraulicResistance R = 1 "Hydraulic resistance";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      end resistance_rec;
    public
      resistance_rec resistance annotation(Dialog);
    protected
      record condenser_rec
        parameter Boolean showName = true;
        Modelica.Units.SI.Pressure p(
          nominal=1000000.0,
          min=611.657,
          max=100000000.0) "Condenser operating pressure";
        parameter Modelica.Units.SI.Volume V_total=10
          "Total volume (liquid + vapor)";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balance";
        Modelica.Units.SI.Volume V_liquid_start
          "Start value of the liquid volume";
        constant Boolean set_m_flow = true "=true to set port_b.m_flow = -port_a.m_flow";
        Real h_fsat(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy of saturated liquid";
        Real h_gsat(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy of saturated vapor";
        Modelica.Units.SI.Density rho_fsat "Density of saturated liquid";
        Modelica.Units.SI.Density rho_gsat "Density of saturated steam";
        Modelica.Units.SI.Mass m_total "Total mass, steam+liquid";
        constant Real _m_total_der(unit = "kg/s") = 0.0 "der(Total mass, steam+liquid)";
        Modelica.Units.SI.Mass m_liquid "Liquid mass";
        Real _m_liquid_der(unit = "kg/s") "der(Liquid mass)";
        Modelica.Units.SI.Mass m_vapor "Steam mass";
        Real _m_vapor_der(unit = "kg/s") "der(Steam mass)";
        Modelica.Units.SI.Volume V_liquid(fixed=false) "Liquid volume";
        Modelica.Units.SI.Volume V_vapor "Steam volume";
        Modelica.Units.SI.Energy E "Internal energy";
        Real _E_der(unit = "W") "der(Internal energy)";
        Modelica.Units.SI.Power Q_total "Total thermal energy removed";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record sat_rec
          Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
          Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
        end sat_rec;
      public
        sat_rec sat;
      end condenser_rec;
    public
      condenser_rec condenser annotation(Dialog);
    protected
      record volume_rec
        constant Modelica.Units.SI.Volume V(min=0.0) = 0.01 "Volume";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balances";
        constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balances";
        constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balances";
        Modelica.Units.SI.AbsolutePressure p_start "Pressure";
        constant Boolean use_T_start = false "Use T_start if true, otherwise h_start";
        constant Modelica.Units.SI.Temperature T_start=293.15 "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h_start "Specific enthalpy";
        parameter Modelica.Units.SI.MassFraction 'X_start[1]'=1.0
          "Mass fraction";
        Modelica.Units.SI.Mass m "Mass";
        Real _m_der(unit = "kg/s") "der(Mass)";
        Modelica.Units.SI.InternalEnergy U "Internal energy";
        Real _U_der(unit = "W") "der(Internal energy)";
        Modelica.Units.SI.MassFlowRate mb
          "Mass flow rate source/sinks within volumes";
        Modelica.Units.SI.HeatFlowRate Ub
          "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
        constant Modelica.Units.SI.Acceleration g_n=9.80665
          "Gravitational acceleration";
        constant Boolean use_HeatPort = false "=true to toggle heat port";
        constant Modelica.Units.SI.HeatFlowRate Q_gen=0
          "Internal heat generation";
        constant Boolean use_TraceMassPort = false "=true to toggle trace mass port";
        parameter Boolean showName = true;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record medium_rec
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 611.657, max = 100000000.0, fixed=false) "Absolute pressure of medium";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0, fixed=false) "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real _d_der(unit = "Pa.m-2.s") "der(Density of medium)";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          Real _u_der(unit = "m2/s3") "der(Specific internal energy of medium)";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          Modelica.Units.NonSI.Pressure_bar p_bar
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
            Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record geometry_rec
          constant Modelica.Units.SI.Volume V=0.01 "Volume";
          constant Modelica.Units.SI.Angle angle(
            min=-1.5807963267948966,
            max=1.5807963267948966) = 0.0
            "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
          constant Modelica.Units.SI.Length dheight=0.0
            "Height(port_b) - Height(port_a)";
          constant Modelica.Units.SI.Length height_a=0
            "Elevation at port_a: Reference value only. No impact on calculations.";
          constant Modelica.Units.SI.Length height_b=0.0
            "Elevation at port_b: Reference value only. No impact on calculations.";
        end geometry_rec;
      public
        geometry_rec geometry;
      end volume_rec;
    public
      volume_rec volume annotation(Dialog);
    protected
      record reservoir_rec
        parameter Modelica.Units.SI.Area A=10 "Cross-sectional area";
        parameter Modelica.Units.SI.Volume V0=0 "Volume at zero level";
        constant Modelica.Units.SI.Pressure p_surface=1000000.0
          "Liquid surface/gas pressure";
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balances";
        constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balances";
        constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balances";
        constant Real g_n(unit = "m/s2") = 9.80665;
        constant Modelica.Units.SI.Pressure p_start=1000000.0;
        parameter Modelica.Units.SI.Length level_start=10 "Start level";
        parameter Modelica.Units.SI.SpecificEnthalpy h_start=100000.0;
        parameter Modelica.Units.SI.MassFraction 'X_start[1]'=1.0
          "Mass fraction";
        Modelica.Units.SI.Length level(fixed=false) "Level";
        Modelica.Units.SI.Volume V "Volume";
        Real _V_der(unit = "m3/s") "der(Volume)";
        Modelica.Units.SI.Mass m "Mmass";
        Real _m_der(unit = "kg/s") "der(Mmass)";
        Modelica.Units.SI.InternalEnergy U "Liquid internal energy";
        Real _U_der(unit = "W") "der(Liquid internal energy)";
        Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0, fixed=false) "Specific enthalpy";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
        Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
        Modelica.Units.SI.MassFlowRate mb
          "Mass flow rate source/sinks within volumes";
        Modelica.Units.SI.HeatFlowRate Ub
          "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
        constant Boolean use_HeatPort = false "=true to toggle heat port";
        constant Modelica.Units.SI.HeatFlowRate Q_gen=0
          "Internal heat generation";
        constant Boolean use_TraceMassPort = false "=true to toggle trace mass port";
        parameter Boolean showName = true;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real _d_der(unit = "Pa.m-2.s") "der(Density)";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Pressure";
        end state_rec;
      public
        state_rec state;
      end reservoir_rec;
    public
      reservoir_rec reservoir annotation(Dialog);
    protected
      record multiPort_rec
        constant Integer nPorts_b = 2 "Number of outlet ports (mass is distributed evenly between the outlet ports";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record 'ports_b[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports_b[1]_rec';
      public
        'ports_b[1]_rec' 'ports_b[1]';
      protected
        record 'ports_b[2]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports_b[2]_rec';
      public
        'ports_b[2]_rec' 'ports_b[2]';
      end multiPort_rec;
    public
      multiPort_rec multiPort;
    protected
      record feedWaterHeater_rec
        constant Modelica.Units.SI.Volume V(min=0.0) = 5 "Volume";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balances";
        constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balances";
        constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balances";
        constant Modelica.Units.SI.AbsolutePressure p_start=1000000.0
          "Pressure";
        constant Boolean use_T_start = false "Use T_start if true, otherwise h_start";
        constant Modelica.Units.SI.Temperature T_start=293.15 "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h_start "Specific enthalpy";
        parameter Modelica.Units.SI.MassFraction 'X_start[1]'=1.0
          "Mass fraction";
        Modelica.Units.SI.Mass m "Mass";
        Real _m_der(unit = "kg/s") "der(Mass)";
        Modelica.Units.SI.InternalEnergy U "Internal energy";
        Real _U_der(unit = "W") "der(Internal energy)";
        Modelica.Units.SI.MassFlowRate mb
          "Mass flow rate source/sinks within volumes";
        Modelica.Units.SI.HeatFlowRate Ub
          "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
        constant Modelica.Units.SI.Acceleration g_n=9.80665
          "Gravitational acceleration";
        constant Boolean use_HeatPort = true "=true to toggle heat port";
        constant Modelica.Units.SI.HeatFlowRate Q_gen=0
          "Internal heat generation";
        constant Boolean use_TraceMassPort = false "=true to toggle trace mass port";
        parameter Boolean showName = true;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record medium_rec
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 611.657, max = 100000000.0, fixed=false) "Absolute pressure of medium";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0, fixed=false) "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real _d_der(unit = "Pa.m-2.s") "der(Density of medium)";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          Real _u_der(unit = "m2/s3") "der(Specific internal energy of medium)";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          Modelica.Units.NonSI.Pressure_bar p_bar
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
            Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record geometry_rec
          constant Modelica.Units.SI.Volume V=5.0 "Volume";
          constant Modelica.Units.SI.Angle angle(
            min=-1.5807963267948966,
            max=1.5807963267948966) = 0.0
            "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
          constant Modelica.Units.SI.Length dheight=0.0
            "Height(port_b) - Height(port_a)";
          constant Modelica.Units.SI.Length height_a=0
            "Elevation at port_a: Reference value only. No impact on calculations.";
          constant Modelica.Units.SI.Length height_b=0.0
            "Elevation at port_b: Reference value only. No impact on calculations.";
        end geometry_rec;
      public
        geometry_rec geometry;
      protected
        record heatPort_rec
          Modelica.Units.SI.Temperature T "Port temperature";
          Modelica.Units.SI.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
        end heatPort_rec;
      public
        heatPort_rec heatPort;
      end feedWaterHeater_rec;
    public
      feedWaterHeater_rec feedWaterHeater annotation(Dialog);
    protected
      record boundary_rec
        parameter Modelica.Units.SI.HeatFlowRate Q_flow=0
          "Heat flow rate at port";
        parameter Boolean showName = true;
        Modelica_Blocks_Interfaces_RealInput Q_flow_ext(unit = "W");
      protected
        record port_rec
          Modelica.Units.SI.HeatFlowRate Q_flow
            "Heat flow rate. Flow from the connection point into the component is positive.";
          Modelica.Units.SI.Temperature T(min=273.15, max=2273.15)
            "Temperature at the connection point";
        end port_rec;
      public
        port_rec port;
      end boundary_rec;
    public
      boundary_rec boundary annotation(Dialog);
    protected
      record PID_rec
        Modelica_Blocks_Interfaces_RealInput u_s(unit = "K") "Connector of setpoint input signal";
        Modelica_Blocks_Interfaces_RealInput u_m(unit = "K", min = 0.0) "Connector of measurement input signal";
        Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Connector of actuator output signal";
        Real controlError(unit = "K") "Control error (set point - measurement)";
        constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
        constant Boolean with_FF = false "enable feed-forward input signal";
        constant Boolean derMeas = true "=true avoid derivative kick";
        parameter Real k = 100000000.0 "Controller gain: +/- for direct/reverse acting";
        parameter Modelica.Units.SI.Time Ti(min=1E-60) = 0.5
          "Time constant of Integrator block";
        parameter Modelica.Units.SI.Time Td(min=0.0) = 0.1
          "Time constant of Derivative block";
        parameter Real yb = 100000000.0 "Output bias. May improve simulation";
        Real k_s(unit = "K-1") "Setpoint input scaling: k_s*u_s. May improve simulation";
        Real k_m(unit = "K-1") "Measurement input scaling: k_m*u_m. May improve simulation";
        parameter Real k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
        parameter Real yMax(unit = "W") = 1E+60 "Upper limit of output";
        Real yMin(unit = "W") "Lower limit of output";
        parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
        parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
        parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
        constant Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
        parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
        parameter Real y_start(unit = "W") = 0 "Initial value of output";
        constant Boolean strict = false "= true, if strict limits with noEvent(..)";
        constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of controller output reset";
        constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
      protected
        record addP_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "K") "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2(unit = "K") "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          Real k1 "Gain of input signal 1";
          parameter Real k2 = -1 "Gain of input signal 2";
        end addP_rec;
      public
        addP_rec addP annotation(Dialog);
      protected
        record P_rec
          parameter Real k = 1 "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end P_rec;
      public
        P_rec P annotation(Dialog);
      protected
        record gainPID_rec
          Real k "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end gainPID_rec;
      public
        gainPID_rec gainPID;
      protected
        record addPID_rec
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = 1 "Gain of input signal 2";
          parameter Real k3 = 1 "Gain of input signal 3";
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end addPID_rec;
      public
        addPID_rec addPID annotation(Dialog);
      protected
        record limiter_rec
          Real uMax(unit = "W") "Upper limits of input signals";
          Real uMin(unit = "W") "Lower limits of input signals";
          constant Boolean strict = false "= true, if strict limits with noEvent(..)";
          constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
          constant Boolean limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
          Modelica_Blocks_Interfaces_RealInput u(unit = "W") "Connector of Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Connector of Real output signal";
        end limiter_rec;
      public
        limiter_rec limiter;
      protected
        record Fzero_rec
          parameter Real k = 0 "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end Fzero_rec;
      public
        Fzero_rec Fzero annotation(Dialog);
      protected
        record addFF_rec
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = 1 "Gain of input signal 2";
          parameter Real k3 = 1 "Gain of input signal 3";
          Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Connector of Real output signal";
        end addFF_rec;
      public
        addFF_rec addFF annotation(Dialog);
      protected
        record gain_u_s_rec
          Real k "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u(unit = "K") "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "K") "Output signal connector";
        end gain_u_s_rec;
      public
        gain_u_s_rec gain_u_s;
      protected
        record gain_u_m_rec
          Real k "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u(unit = "K") "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "K") "Output signal connector";
        end gain_u_m_rec;
      public
        gain_u_m_rec gain_u_m;
      protected
        record null_bias_rec
          Real k "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end null_bias_rec;
      public
        null_bias_rec null_bias;
      protected
        record I_rec
          Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
          Modelica_Blocks_Interfaces_RealOutput y(fixed=false) "Connector of Real output signal";
          Real k "Integrator gain";
          constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
          constant Real y_start = 0.0 "Initial or guess value of output (= state)";
          constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of integrator reset";
          constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
        end I_rec;
      public
        I_rec I;
      protected
        record addI_rec
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = -1 "Gain of input signal 2";
          parameter Real k3 = 1 "Gain of input signal 3";
          Modelica_Blocks_Interfaces_RealInput u1(unit = "K") "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2(unit = "K") "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end addI_rec;
      public
        addI_rec addI annotation(Dialog);
      protected
        record addSat_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "W") "Connector of Real input signal 1";
          Modelica_Blocks_Interfaces_RealInput u2(unit = "W") "Connector of Real input signal 2";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          parameter Real k1 = 1 "Gain of input signal 1";
          parameter Real k2 = -1 "Gain of input signal 2";
        end addSat_rec;
      public
        addSat_rec addSat annotation(Dialog);
      protected
        record gainTrack_rec
          Real k "Gain value multiplied with input signal";
          Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
          Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
        end gainTrack_rec;
      public
        gainTrack_rec gainTrack;
      protected
        record Dzero_rec
          parameter Real k = 0 "Constant output value";
          Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
        end Dzero_rec;
      public
        Dzero_rec Dzero annotation(Dialog);
      end PID_rec;
    public
      PID_rec PID annotation(Dialog);
    protected
      record realExpression_rec
        Modelica_Blocks_Interfaces_RealOutput y(unit = "K") "Value of Real output";
      end realExpression_rec;
    public
      realExpression_rec realExpression;
    protected
      record temperature_rec
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showName = true "= false to hide component name";
        parameter Integer precision(min = 0) = 0 "Number of decimals displayed";
        Real var(unit = "K") "Variable to be converted";
        Real y "Icon display";
        Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature", min = 0.0) "Temperature in port medium";
      protected
        record port_rec
          constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) = 0 "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_rec;
      public
        port_rec port;
      end temperature_rec;
    public
      temperature_rec temperature annotation(Dialog);
    protected
      record multiPort1_rec
        constant Integer nPorts_b = 3 "Number of outlet ports (mass is distributed evenly between the outlet ports";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
          Real _h_outflow_der(unit = "m2/s3") "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0)";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record 'ports_b[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports_b[1]_rec';
      public
        'ports_b[1]_rec' 'ports_b[1]';
      protected
        record 'ports_b[2]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports_b[2]_rec';
      public
        'ports_b[2]_rec' 'ports_b[2]';
      protected
        record 'ports_b[3]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports_b[3]_rec';
      public
        'ports_b[3]_rec' 'ports_b[3]';
      end multiPort1_rec;
    public
      multiPort1_rec multiPort1;
    protected
      record resistance1_rec
        Modelica.Units.SI.PressureDifference dp;
        Modelica.Units.SI.MassFlowRate m_flow;
        parameter Boolean showName = true;
        constant TRANSFORM_Units_HydraulicResistance R = 1 "Hydraulic resistance";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      end resistance1_rec;
    public
      resistance1_rec resistance1 annotation(Dialog);
    protected
      record pressure_rec
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showName = true "= false to hide component name";
        parameter Integer precision(min = 0) = 0 "Number of decimals displayed";
        Modelica_Blocks_Interfaces_RealOutput p(unit = "Pa", displayUnit = "bar", quantity = "Pressure", min = 0.0) "Pressure at port";
      protected
        record port_rec
          constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) = 0 "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_rec;
      public
        port_rec port;
      end pressure_rec;
    public
      pressure_rec pressure annotation(Dialog);
    protected
      record valve_BV_rec
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showDesignFlowDirection = true "= false to hide the flow direction arrow";
        parameter Boolean showName = true "= false to hide component name";
        Real dp_start(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = -1E+60, max = 100000000.0) "Guess value of dp = port_a.p - port_b.p";
        Real m_flow_start(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Guess value of m_flow = port_a.m_flow";
        Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Small mass flow rate for regularization of zero flow";
        constant Boolean show_T = true "= true, if temperatures at port_a and port_b are computed";
        constant Boolean show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate in design flow direction";
        Modelica.Units.SI.Pressure dp
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
        Modelica.Units.SI.VolumeFlowRate V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
        Real port_a_T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature close to port_a, if show_T = true";
        Real port_b_T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature close to port_b, if show_T = true";
        constant Modelica.Fluid.Types.CvTypes CvData = Modelica.Fluid.Types.CvTypes.OpPoint "Selection of flow coefficient";
        parameter Modelica.Units.SI.Area Av(fixed=false)
          "Av (metric) flow coefficient";
        parameter Real Kv = 0 "Kv (metric) flow coefficient [m3/h]";
        parameter Real Cv = 0 "Cv (US) flow coefficient [USG/min]";
        parameter Modelica.Units.SI.Pressure dp_nominal=100000
          "Nominal pressure drop";
        Real m_flow_nominal(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Nominal mass flowrate";
        Real rho_nominal(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Nominal inlet density";
        parameter Real opening_nominal(min = 0.0, max = 1.0) = 1 "Nominal opening";
        constant Boolean filteredOpening = false "= true, if opening is filtered with a 2nd order CriticalDamping filter";
        parameter Modelica.Units.SI.Time riseTime=1
          "Rise time of the filter (time to reach 99.6 % of an opening step)";
        parameter Real leakageOpening(min = 0.0, max = 1.0) = 0.001 "The opening signal is limited by leakageOpening (to improve the numerics)";
        constant Boolean checkValve = false "Reverse flow stopped";
        Modelica.Units.SI.Pressure dp_small(nominal=100000.0, min=0.0)
          "Regularisation of zero flow";
        constant Modelica.Units.SI.Area Kv2Av=2.77E-05 "Conversion factor";
        constant Modelica.Units.SI.Area Cv2Av=2.4E-05 "Conversion factor";
        Modelica_Blocks_Interfaces_RealInput opening(min = 0.0, max = 1.0) "Valve position in the range 0..1";
        Real p_nominal(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Nominal inlet pressure";
        parameter Real Fxt_full = 0.5 "Fk*xt critical ratio at full opening";
        Real Fxt;
        Real x "Pressure drop ratio";
        Real xs "Saturated pressure drop ratio";
        Real Y "Compressibility factor";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Inlet pressure";
        constant Modelica.Units.SI.ReynoldsNumber Re_turbulent=4000
          "cf. straight pipe for fully open valve -- dp_turbulent increases for closing valve";
        constant Boolean use_Re = false "= true, if turbulent region is defined by Re, otherwise by m_flow_small";
        Modelica.Units.SI.AbsolutePressure dp_turbulent;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end valve_BV_rec;
    public
      valve_BV_rec valve_BV annotation(Dialog);
    protected
      record volume_bypass_rec
        constant Modelica.Units.SI.Volume V(min=0.0) = 0.01 "Volume";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balances";
        constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balances";
        constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balances";
        Modelica.Units.SI.AbsolutePressure p_start "Pressure";
        constant Boolean use_T_start = false "Use T_start if true, otherwise h_start";
        constant Modelica.Units.SI.Temperature T_start=293.15 "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h_start "Specific enthalpy";
        parameter Modelica.Units.SI.MassFraction 'X_start[1]'=1.0
          "Mass fraction";
        Modelica.Units.SI.Mass m "Mass";
        Real _m_der(unit = "kg/s") "der(Mass)";
        Modelica.Units.SI.InternalEnergy U "Internal energy";
        Real _U_der(unit = "W") "der(Internal energy)";
        Modelica.Units.SI.MassFlowRate mb
          "Mass flow rate source/sinks within volumes";
        Modelica.Units.SI.HeatFlowRate Ub
          "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
        constant Modelica.Units.SI.Acceleration g_n=9.80665
          "Gravitational acceleration";
        constant Boolean use_HeatPort = false "=true to toggle heat port";
        constant Modelica.Units.SI.HeatFlowRate Q_gen=0
          "Internal heat generation";
        constant Boolean use_TraceMassPort = false "=true to toggle trace mass port";
        parameter Boolean showName = true;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record medium_rec
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 611.657, max = 100000000.0, fixed=false) "Absolute pressure of medium";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0, fixed=false) "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real _d_der(unit = "Pa.m-2.s") "der(Density of medium)";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          Real _u_der(unit = "m2/s3") "der(Specific internal energy of medium)";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          Modelica.Units.NonSI.Pressure_bar p_bar
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
            Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record geometry_rec
          constant Modelica.Units.SI.Volume V=0.01 "Volume";
          constant Modelica.Units.SI.Angle angle(
            min=-1.5807963267948966,
            max=1.5807963267948966) = 0.0
            "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
          constant Modelica.Units.SI.Length dheight=0.0
            "Height(port_b) - Height(port_a)";
          constant Modelica.Units.SI.Length height_a=0
            "Elevation at port_a: Reference value only. No impact on calculations.";
          constant Modelica.Units.SI.Length height_b=0.0
            "Elevation at port_b: Reference value only. No impact on calculations.";
        end geometry_rec;
      public
        geometry_rec geometry;
      end volume_bypass_rec;
    public
      volume_bypass_rec volume_bypass annotation(Dialog);
    protected
      record resistance3_rec
        Modelica.Units.SI.PressureDifference dp;
        Modelica.Units.SI.MassFlowRate m_flow;
        parameter Boolean showName = true;
        constant TRANSFORM_Units_HydraulicResistance R = 1 "Hydraulic resistance";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      end resistance3_rec;
    public
      resistance3_rec resistance3 annotation(Dialog);
    protected
      record W_balance1_rec
        constant Modelica_Blocks_Interfaces_RealOutput y = 0.0 "Value of Real output";
      end W_balance1_rec;
    public
      W_balance1_rec W_balance1;
    protected
      record valve_TCV_rec
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showDesignFlowDirection = true "= false to hide the flow direction arrow";
        parameter Boolean showName = true "= false to hide component name";
        Real dp_start(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = -1E+60, max = 100000000.0) "Guess value of dp = port_a.p - port_b.p";
        Real m_flow_start(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Guess value of m_flow = port_a.m_flow";
        Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Small mass flow rate for regularization of zero flow";
        constant Boolean show_T = true "= true, if temperatures at port_a and port_b are computed";
        constant Boolean show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate in design flow direction";
        Modelica.Units.SI.Pressure dp
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
        Modelica.Units.SI.VolumeFlowRate V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
        Real port_a_T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature close to port_a, if show_T = true";
        Real port_b_T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature close to port_b, if show_T = true";
        constant Modelica.Fluid.Types.CvTypes CvData = Modelica.Fluid.Types.CvTypes.OpPoint "Selection of flow coefficient";
        parameter Modelica.Units.SI.Area Av(fixed=false)
          "Av (metric) flow coefficient";
        parameter Real Kv = 0 "Kv (metric) flow coefficient [m3/h]";
        parameter Real Cv = 0 "Cv (US) flow coefficient [USG/min]";
        parameter Modelica.Units.SI.Pressure dp_nominal=100000
          "Nominal pressure drop";
        Real m_flow_nominal(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Nominal mass flowrate";
        Real rho_nominal(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Nominal inlet density";
        parameter Real opening_nominal(min = 0.0, max = 1.0) = 1 "Nominal opening";
        constant Boolean filteredOpening = false "= true, if opening is filtered with a 2nd order CriticalDamping filter";
        parameter Modelica.Units.SI.Time riseTime=1
          "Rise time of the filter (time to reach 99.6 % of an opening step)";
        parameter Real leakageOpening(min = 0.0, max = 1.0) = 0.001 "The opening signal is limited by leakageOpening (to improve the numerics)";
        constant Boolean checkValve = false "Reverse flow stopped";
        Modelica.Units.SI.Pressure dp_small(nominal=100000.0, min=0.0)
          "Regularisation of zero flow";
        constant Modelica.Units.SI.Area Kv2Av=2.77E-05 "Conversion factor";
        constant Modelica.Units.SI.Area Cv2Av=2.4E-05 "Conversion factor";
        Modelica_Blocks_Interfaces_RealInput opening(min = 0.0, max = 1.0) "Valve position in the range 0..1";
        Real p_nominal(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Nominal inlet pressure";
        parameter Real Fxt_full = 0.5 "Fk*xt critical ratio at full opening";
        Real Fxt;
        Real x "Pressure drop ratio";
        Real xs "Saturated pressure drop ratio";
        Real Y "Compressibility factor";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Inlet pressure";
        constant Modelica.Units.SI.ReynoldsNumber Re_turbulent=4000
          "cf. straight pipe for fully open valve -- dp_turbulent increases for closing valve";
        constant Boolean use_Re = false "= true, if turbulent region is defined by Re, otherwise by m_flow_small";
        Modelica.Units.SI.AbsolutePressure dp_turbulent;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end valve_TCV_rec;
    public
      valve_TCV_rec valve_TCV annotation(Dialog);
    protected
      record header_rec
        constant Integer nPorts_a = 1 "Number of port_a connections";
        constant Integer nPorts_b = 3 "Number of port_b connections";
        constant Modelica.Units.SI.Volume V(min=0.0) = 1 "Volume";
        constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
        constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balances";
        constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balances";
        constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balances";
        Modelica.Units.SI.AbsolutePressure p_start "Pressure";
        constant Boolean use_T_start = false "Use T_start if true, otherwise h_start";
        constant Modelica.Units.SI.Temperature T_start=293.15 "Temperature";
        Modelica.Units.SI.SpecificEnthalpy h_start "Specific enthalpy";
        parameter Modelica.Units.SI.MassFraction 'X_start[1]'=1.0
          "Mass fraction";
        Modelica.Units.SI.Mass m(nominal=500.0, max=100000.0) "Mass";
        Real _m_der(unit = "kg/s") "der(Mass)";
        Modelica.Units.SI.InternalEnergy U "Internal energy";
        Real _U_der(unit = "W") "der(Internal energy)";
        Modelica.Units.SI.MassFlowRate mb
          "Mass flow rate source/sinks within volumes";
        Modelica.Units.SI.HeatFlowRate Ub
          "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
        constant Modelica.Units.SI.Acceleration g_n=9.80665
          "Gravitational acceleration";
        Modelica.Units.SI.HeatFlowRate 'H_flows_a[1]'
          "Enthalpy flow rates at port_a";
        Modelica.Units.SI.HeatFlowRate 'H_flows_b[1]'
          "Enthalpy flow rates at port_b";
        Modelica.Units.SI.HeatFlowRate 'H_flows_b[2]'
          "Enthalpy flow rates at port_b";
        constant Modelica.Units.SI.HeatFlowRate 'H_flows_b[3]'=0.0
          "Enthalpy flow rates at port_b";
        constant Boolean use_HeatPort = false "=true to toggle heat port";
        constant Modelica.Units.SI.HeatFlowRate Q_gen=0
          "Internal heat generation";
        constant Boolean use_TraceMassPort = false "=true to toggle trace mass port";
        parameter Boolean showName = true;
      protected
        record 'port_a[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'port_a[1]_rec';
      public
        'port_a[1]_rec' 'port_a[1]';
      protected
        record 'port_b[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'port_b[1]_rec';
      public
        'port_b[1]_rec' 'port_b[1]';
      protected
        record 'port_b[2]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'port_b[2]_rec';
      public
        'port_b[2]_rec' 'port_b[2]';
      protected
        record 'port_b[3]_rec'
          constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) = 0.0 "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'port_b[3]_rec';
      public
        'port_b[3]_rec' 'port_b[3]';
      protected
        record medium_rec
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 611.657, max = 100000000.0, fixed=false) "Absolute pressure of medium";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0, fixed=false) "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          Real _u_der(unit = "m2/s3") "der(Specific internal energy of medium)";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          Modelica.Units.NonSI.Pressure_bar p_bar
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
            Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record geometry_rec
          constant Modelica.Units.SI.Volume V=1.0 "Volume";
          constant Modelica.Units.SI.Angle angle(
            min=-1.5807963267948966,
            max=1.5807963267948966) = 0.0
            "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
          constant Modelica.Units.SI.Length dheight=0.0
            "Height(port_b) - Height(port_a)";
          constant Modelica.Units.SI.Length height_a=0
            "Elevation at port_a: Reference value only. No impact on calculations.";
          constant Modelica.Units.SI.Length height_b=0.0
            "Elevation at port_b: Reference value only. No impact on calculations.";
        end geometry_rec;
      public
        geometry_rec geometry;
      end header_rec;
    public
      header_rec header annotation(Dialog);
    protected
      record resistance4_rec
        Modelica.Units.SI.PressureDifference dp;
        Modelica.Units.SI.MassFlowRate m_flow;
        parameter Boolean showName = true;
        constant TRANSFORM_Units_HydraulicResistance R = 1 "Hydraulic resistance";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      end resistance4_rec;
    public
      resistance4_rec resistance4 annotation(Dialog);
    protected
      record 'boundary_a3[1]_rec'
        parameter Boolean showName = true;
        constant Integer nPorts = 1 "Number of ports";
        constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Fixed value of pressure";
        Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Fixed value of specific enthalpy";
        constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Fixed value of composition";
      protected
        record medium_rec
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0) = 1000000.0 "Absolute pressure of medium";
          Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          constant Modelica.Units.NonSI.Pressure_bar p_bar=10.0
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            constant Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Saturation pressure";
            constant Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) = 453.0356323914667 "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record 'ports[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports[1]_rec';
      public
        'ports[1]_rec' 'ports[1]';
      end 'boundary_a3[1]_rec';
    public
      'boundary_a3[1]_rec' 'boundary_a3[1]' annotation(Dialog);
    protected
      record 'checkValve[1]_rec'
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showDesignFlowDirection = true "= false to hide the flow direction arrow";
        parameter Boolean showName = true "= false to hide component name";
        constant TRANSFORM_Units_HydraulicResistance R = 1E-15 "Hydraulic resistance";
        constant Boolean checkValve = true "Reverse flow stopped";
        Modelica.Units.SI.MassFlowRate m_flow_start "Mass flow rate";
        Modelica.Units.SI.MassFlowRate m_flow;
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end 'checkValve[1]_rec';
    public
      'checkValve[1]_rec' 'checkValve[1]' annotation(Dialog);
    protected
      record 'boundary_m_flow_a3[1]_rec'
        parameter Boolean showName = true;
        constant Integer nPorts = 1 "Number of ports";
        constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) = 0 "Fixed mass flow rate going out of the fluid port";
        Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Fixed value of specific enthalpy";
        constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Fixed value of composition";
        Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
        Modelica_Blocks_Interfaces_RealInput h_in(unit = "J/kg") "Prescribed fluid specific enthalpy";
      protected
        record medium_rec
          Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0) "Absolute pressure of medium";
          Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          Modelica.Units.NonSI.Pressure_bar p_bar
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
            Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record 'ports[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports[1]_rec';
      public
        'ports[1]_rec' 'ports[1]';
      end 'boundary_m_flow_a3[1]_rec';
    public
      'boundary_m_flow_a3[1]_rec' 'boundary_m_flow_a3[1]' annotation(Dialog);
    protected
      record 'massFlowRate[1]_rec'
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showName = true "= false to hide component name";
        parameter Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = 0.0, max = 100000.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
        parameter Integer precision(min = 0) = 0 "Number of decimals displayed";
        Real var(unit = "kg/s") "Variable to be converted";
        Real y "Icon display";
        Modelica_Blocks_Interfaces_RealOutput m_flow(unit = "kg/s", quantity = "MassFlowRate") "Mass flow rate from port_a to port_b";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end 'massFlowRate[1]_rec';
    public
      'massFlowRate[1]_rec' 'massFlowRate[1]' annotation(Dialog);
    protected
      record 'specificEnthalpy[1]_rec'
        constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
        parameter Boolean showName = true "= false to hide component name";
        parameter Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = 0.0, max = 100000.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
        parameter Integer precision(min = 0) = 0 "Number of decimals displayed";
        Real var(unit = "J/kg") "Variable to be converted";
        Real y "Icon display";
        Modelica_Blocks_Interfaces_RealOutput h_out(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of the passing fluid";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      end 'specificEnthalpy[1]_rec';
    public
      'specificEnthalpy[1]_rec' 'specificEnthalpy[1]' annotation(Dialog);
    protected
      record powerSensor_rec
        Modelica_Blocks_Interfaces_RealOutput power(unit = "W") "Power in flange flange_a as output signal";
      protected
        record flange_a_rec
          Modelica.Units.SI.Angle phi "Absolute rotation angle of flange";
          Real _phi_der(unit = "rad/s") "der(Absolute rotation angle of flange)";
          Modelica.Units.SI.Torque tau "Cut torque in the flange";
        end flange_a_rec;
      public
        flange_a_rec flange_a;
      protected
        record flange_b_rec
          Modelica.Units.SI.Angle phi "Absolute rotation angle of flange";
          Modelica.Units.SI.Torque tau "Cut torque in the flange";
        end flange_b_rec;
      public
        flange_b_rec flange_b;
      end powerSensor_rec;
    public
      powerSensor_rec powerSensor;
    protected
      record resistance2_rec
        Modelica.Units.SI.PressureDifference dp;
        Modelica.Units.SI.MassFlowRate m_flow;
        parameter Boolean showName = true;
        constant TRANSFORM_Units_HydraulicResistance R = 1 "Hydraulic resistance";
      protected
        record port_a_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_a_rec;
      public
        port_a_rec port_a;
      protected
        record port_b_rec
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end port_b_rec;
      public
        port_b_rec port_b;
      protected
        record state_rec
          constant Integer phase(min = 0, max = 2) = 0 "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      end resistance2_rec;
    public
      resistance2_rec resistance2 annotation(Dialog);
    protected
      record PID1_rec
        Modelica_Blocks_Interfaces_RealInput u_s(unit = "m") "Connector of setpoint input signal";
        Modelica_Blocks_Interfaces_RealInput u_m(unit = "m") "Connector of measurement input signal";
        Modelica_Blocks_Interfaces_RealOutput y(unit = "kg/s") "Connector of actuator output signal";
        constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
        constant Boolean derMeas = true "=true avoid derivative kick";
        parameter Real k = 100.0 "Controller gain: +/- for direct/reverse acting";
        parameter Modelica.Units.SI.Time Ti(min=1E-60) = 0.5
          "Time constant of Integrator block";
        parameter Modelica.Units.SI.Time Td(min=0.0) = 0.1
          "Time constant of Derivative block";
        parameter Real yb = 0 "Output bias. May improve simulation";
        Real k_s(unit = "m-1") "Setpoint input scaling: k_s*u_s. May improve simulation";
        Real k_m(unit = "m-1") "Measurement input scaling: k_m*u_m. May improve simulation";
        parameter Real yMax(unit = "kg/s") = 1E+60 "Upper limit of output";
        parameter Real yMin(unit = "kg/s") = 0 "Lower limit of output";
        parameter Real wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
        parameter Real Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
        parameter Real Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
        constant Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
        constant Real xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
        parameter Real xd_start = 0 "Initial or guess value for state of derivative block";
        parameter Real y_start(unit = "kg/s") = 0 "Initial value of output";
        constant Boolean strict = false "= true, if strict limits with noEvent(..)";
        Real eOn "if off and control error > eOn, switch to set point tracking";
        Real eOff "if on and control error < eOff, set y=0";
        parameter Boolean pre_y_start = false "Value of hysteresis output at initial time";
      protected
        record PID_rec
          Modelica_Blocks_Interfaces_RealInput u_s(unit = "m") "Connector of setpoint input signal";
          Modelica_Blocks_Interfaces_RealInput u_m(unit = "m") "Connector of measurement input signal";
          Modelica_Blocks_Interfaces_RealOutput y(unit = "kg/s") "Connector of actuator output signal";
          Real controlError(unit = "m") "Control error (set point - measurement)";
          constant Modelica.Blocks.Types.SimpleController controllerType = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
          constant Boolean with_FF = false "enable feed-forward input signal";
          constant Boolean derMeas = true "=true avoid derivative kick";
          Real k "Controller gain: +/- for direct/reverse acting";
          Modelica.Units.SI.Time Ti(min=1E-60)
            "Time constant of Integrator block";
          Modelica.Units.SI.Time Td(min=0.0)
            "Time constant of Derivative block";
          Real yb "Output bias. May improve simulation";
          Real k_s(unit = "m-1") "Setpoint input scaling: k_s*u_s. May improve simulation";
          Real k_m(unit = "m-1") "Measurement input scaling: k_m*u_m. May improve simulation";
          parameter Real k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
          Real yMax(unit = "kg/s") "Upper limit of output";
          Real yMin(unit = "kg/s") "Lower limit of output";
          Real wp(min = 0.0) "Set-point weight for Proportional block (0..1)";
          Real wd(min = 0.0) "Set-point weight for Derivative block (0..1)";
          Real Ni(min = 1E-13) "Ni*Ti is time constant of anti-windup compensation";
          Real Nd(min = 1E-13) "The higher Nd, the more ideal the derivative block";
          constant Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
            "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
          constant Real xi_start = 0.0 "Initial or guess value value for integrator output (= integrator state)";
          Real xd_start "Initial or guess value for state of derivative block";
          Real y_start(unit = "kg/s") "Initial value of output";
          constant Boolean strict = false "= true, if strict limits with noEvent(..)";
          constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of controller output reset";
          constant Real y_reset = 0.0 "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
        protected
          record addP_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "m") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "m") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            Real k1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addP_rec;
        public
          addP_rec addP annotation(Dialog);
        protected
          record P_rec
            parameter Real k = 1 "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end P_rec;
        public
          P_rec P annotation(Dialog);
        protected
          record gainPID_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainPID_rec;
        public
          gainPID_rec gainPID;
        protected
          record addPID_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addPID_rec;
        public
          addPID_rec addPID annotation(Dialog);
        protected
          record limiter_rec
            Real uMax(unit = "kg/s") "Upper limits of input signals";
            Real uMin(unit = "kg/s") "Lower limits of input signals";
            constant Boolean strict = false "= true, if strict limits with noEvent(..)";
            constant Modelica.Blocks.Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
            constant Boolean limitsAtInit = true "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)";
            Modelica_Blocks_Interfaces_RealInput u(unit = "kg/s") "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "kg/s") "Connector of Real output signal";
          end limiter_rec;
        public
          limiter_rec limiter;
        protected
          record Fzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Fzero_rec;
        public
          Fzero_rec Fzero annotation(Dialog);
        protected
          record addFF_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = 1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1 "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2 "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "kg/s") "Connector of Real output signal";
          end addFF_rec;
        public
          addFF_rec addFF annotation(Dialog);
        protected
          record gain_u_s_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "m") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "m") "Output signal connector";
          end gain_u_s_rec;
        public
          gain_u_s_rec gain_u_s;
        protected
          record gain_u_m_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u(unit = "m") "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y(unit = "m") "Output signal connector";
          end gain_u_m_rec;
        public
          gain_u_m_rec gain_u_m;
        protected
          record null_bias_rec
            Real k "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end null_bias_rec;
        public
          null_bias_rec null_bias;
        protected
          record I_rec
            Modelica_Blocks_Interfaces_RealInput u "Connector of Real input signal";
            Modelica_Blocks_Interfaces_RealOutput y(fixed=false) "Connector of Real output signal";
            Real k "Integrator gain";
            constant Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
            constant Real y_start = 0.0 "Initial or guess value of output (= state)";
            constant TRANSFORM_Types_Reset reset = TRANSFORM_Types_Reset.Disabled "Type of integrator reset";
            constant Real y_reset = 0.0 "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
          end I_rec;
        public
          I_rec I;
        protected
          record addI_rec
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
            parameter Real k3 = 1 "Gain of input signal 3";
            Modelica_Blocks_Interfaces_RealInput u1(unit = "m") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "m") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealInput u3 "Connector of Real input signal 3";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end addI_rec;
        public
          addI_rec addI annotation(Dialog);
        protected
          record addSat_rec
            Modelica_Blocks_Interfaces_RealInput u1(unit = "kg/s") "Connector of Real input signal 1";
            Modelica_Blocks_Interfaces_RealInput u2(unit = "kg/s") "Connector of Real input signal 2";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
            parameter Real k1 = 1 "Gain of input signal 1";
            parameter Real k2 = -1 "Gain of input signal 2";
          end addSat_rec;
        public
          addSat_rec addSat annotation(Dialog);
        protected
          record gainTrack_rec
            Real k "Gain value multiplied with input signal";
            Modelica_Blocks_Interfaces_RealInput u "Input signal connector";
            Modelica_Blocks_Interfaces_RealOutput y "Output signal connector";
          end gainTrack_rec;
        public
          gainTrack_rec gainTrack;
        protected
          record Dzero_rec
            parameter Real k = 0 "Constant output value";
            Modelica_Blocks_Interfaces_RealOutput y "Connector of Real output signal";
          end Dzero_rec;
        public
          Dzero_rec Dzero annotation(Dialog);
        end PID_rec;
      public
        PID_rec PID annotation(Dialog);
      protected
        record hys_rec
          Real uLow "if y=true and u<=uLow, switch to y=false";
          Real uHigh "if y=false and u>=uHigh, switch to y=true";
          Boolean pre_y_start "Value of pre(y) at initial time";
          Modelica_Blocks_Interfaces_RealInput u(unit = "m");
          Modelica_Blocks_Interfaces_BooleanOutput y;
        end hys_rec;
      public
        hys_rec hys;
      protected
        record feeBac_rec
          Modelica_Blocks_Interfaces_RealInput u1(unit = "m");
          Modelica_Blocks_Interfaces_RealInput u2(unit = "m");
          Modelica_Blocks_Interfaces_RealOutput y(unit = "m");
        end feeBac_rec;
      public
        feeBac_rec feeBac;
      end PID1_rec;
    public
      PID1_rec PID1 annotation(Dialog);
    protected
      record level_setpoint_rec
        Modelica_Blocks_Interfaces_RealOutput y(unit = "m") "Value of Real output";
      end level_setpoint_rec;
    public
      level_setpoint_rec level_setpoint;
    protected
      record level_measure_rec
        Modelica_Blocks_Interfaces_RealOutput y(unit = "m") "Value of Real output";
      end level_measure_rec;
    public
      level_measure_rec level_measure;
    protected
      record boundary2_rec
        parameter Boolean showName = true;
        constant Integer nPorts = 1 "Number of ports";
        constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) = 0 "Fixed mass flow rate going out of the fluid port";
        constant Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) = 298.15 "Fixed value of temperature";
        constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Fixed value of composition";
        Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s") "Prescribed mass flow rate";
      protected
        record medium_rec
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0) = 1000000.0 "Absolute pressure of medium";
          Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
          constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
          Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
          constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
          constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
          constant Boolean preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
          constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.Units.NonSI.Temperature_degC T_degC
            "Temperature of medium in [degC]";
          constant Modelica.Units.NonSI.Pressure_bar p_bar=10.0
            "Absolute pressure of medium in [bar]";
          Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
        protected
          record state_rec
            Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
            Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
            Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
            Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
            constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Pressure";
          end state_rec;
        public
          state_rec state;
        protected
          record sat_rec
            constant Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Saturation pressure";
            constant Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) = 453.0356323914667 "Saturation temperature";
          end sat_rec;
        public
          sat_rec sat;
        end medium_rec;
      public
        medium_rec medium;
      protected
        record 'ports[1]_rec'
          Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
          constant Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) = 1000000.0 "Thermodynamic pressure in the connection point";
          Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        end 'ports[1]_rec';
      public
        'ports[1]_rec' 'ports[1]';
      end boundary2_rec;
    public
      boundary2_rec boundary2 annotation(Dialog);
    end BOP_rec;
  public
    BOP_rec BOP annotation(Dialog);
  protected
    record sinkElec_rec
      constant Boolean use_port = false "= true to use input signal";
      parameter Modelica.Units.SI.Frequency f=60 "Frequency";
    protected
      record port_rec
        Modelica.Units.SI.Power W "Active power";
        Modelica.Units.SI.Frequency f "Frequency";
      end port_rec;
    public
      port_rec port;
    end sinkElec_rec;
  public
    sinkElec_rec sinkElec annotation(Dialog);
  protected
    record source1_rec
      constant Integer nPorts = 1 "Number of ports";
      parameter Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) = 0 "Fixed mass flow rate going out of the fluid port";
      parameter Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) = 3000000.0 "Fixed value of specific enthalpy";
      parameter Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Fixed value of composition";
    protected
      record medium_rec
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0) "Absolute pressure of medium";
        Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
        Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
        Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature of medium";
        constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 1.0 "Mass fractions (= (component mass)/total mass  m_i/m)";
        Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
        constant Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) = 461.52295930318655 "Gas constant (of mixture if applicable)";
        constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.018015268 "Molar mass (of mixture or single fluid)";
        constant Boolean preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
        constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.Units.NonSI.Temperature_degC T_degC
          "Temperature of medium in [degC]";
        Modelica.Units.NonSI.Pressure_bar p_bar
          "Absolute pressure of medium in [bar]";
        Integer phase(min = 0, max = 2) "2 for two-phase, 1 for one-phase, 0 if not known";
      protected
        record state_rec
          Integer phase(min = 0, max = 2) "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
          Real h(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific enthalpy";
          Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 500.0, quantity = "Density", min = 0.0, max = 100000.0) "Density";
          Real T(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Temperature";
          Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Pressure";
        end state_rec;
      public
        state_rec state;
      protected
        record sat_rec
          Real psat(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Saturation pressure";
          Real Tsat(unit = "K", displayUnit = "degC", nominal = 500.0, quantity = "ThermodynamicTemperature", min = 273.15, max = 2273.15) "Saturation temperature";
        end sat_rec;
      public
        sat_rec sat;
      end medium_rec;
    public
      medium_rec medium;
    protected
      record 'ports[1]_rec'
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end 'ports[1]_rec';
    public
      'ports[1]_rec' 'ports[1]';
    end source1_rec;
  public
    source1_rec source1 annotation(Dialog);
  protected
    record realExpression2_rec
      Modelica_Blocks_Interfaces_RealOutput y(unit = "W") "Value of Real output";
    end realExpression2_rec;
  public
    realExpression2_rec realExpression2;
  protected
    record realExpression3_rec
      Modelica_Blocks_Interfaces_RealOutput y(unit = "s-1") "Value of Real output";
    end realExpression3_rec;
  public
    realExpression3_rec realExpression3;
  protected
    record massFlowToPressure_rec
      constant Modelica.Units.SI.AbsolutePressure p_atm=1000000.0
        "Atmospheric pressure";
      Modelica_Blocks_Interfaces_RealInput m_flow_in(unit = "kg/s", quantity = "MassFlowRate") "Prescribed mass flow rate [kg/s]";
      Modelica_Blocks_Interfaces_RealInput h_in(unit = "J/kg", quantity = "SpecificEnthalpy") "Prescribed specific enthalpy";
      Modelica_Blocks_Interfaces_RealOutput h_out(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnthalpy", min = -10000000000.0, max = 10000000000.0);
      Modelica_Blocks_Interfaces_RealOutput p_out(unit = "Pa", quantity = "Pressure");
      parameter Modelica.Units.SI.SpecificEnthalpy h0_causal=0
        "Specific Enthalpy offset from causal side";
      parameter Modelica.Units.SI.SpecificEnthalpy h0_acausal=0
        "Specific Enthalpy offset on acausal side";
    protected
      record fluidPort_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end fluidPort_rec;
    public
      fluidPort_rec fluidPort;
    end massFlowToPressure_rec;
  public
    massFlowToPressure_rec massFlowToPressure annotation(Dialog);
  protected
    record pressureToMassFlow_rec
      Modelica.Units.SI.AbsolutePressure p_atm "Atmospheric pressure";
      Modelica_Blocks_Interfaces_RealInput p_in(unit = "Pa", quantity = "Pressure") "Prescribed pressure";
      Modelica_Blocks_Interfaces_RealInput h_in(unit = "J/kg", quantity = "SpecificEnthalpy") "Prescribed specific enthalpy";
      Modelica_Blocks_Interfaces_RealOutput m_flow_out(unit = "kg/s", quantity = "MassFlowRate");
      Modelica_Blocks_Interfaces_RealOutput h_out(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnthalpy", min = -10000000000.0, max = 10000000000.0);
      parameter Modelica.Units.SI.SpecificEnthalpy h0_causal=0
        "Specific Enthalpy offset from causal side";
      parameter Modelica.Units.SI.SpecificEnthalpy h0_acausal=0
        "Specific Enthalpy offset on acausal side";
    protected
      record fluidPort_rec
        Real m_flow(unit = "kg/s", quantity = "MassFlowRate.WaterIF97", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
        Real p(unit = "Pa", displayUnit = "bar", nominal = 1000000.0, quantity = "Pressure", min = 611.657, max = 100000000.0) "Thermodynamic pressure in the connection point";
        Real h_outflow(unit = "J/kg", nominal = 500000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      end fluidPort_rec;
    public
      fluidPort_rec fluidPort annotation(Dialog);
    end pressureToMassFlow_rec;
  public
    pressureToMassFlow_rec pressureToMassFlow annotation(Dialog);
    parameter Real _BOP_Demand_start = 0.0
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput BOP_Demand(unit = "W", start = _BOP_Demand_start)
    annotation (Placement(transformation(extent={{-124,47},{-84,87}})));
    parameter Real _h_in_port_a_start = 0.0
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput h_in_port_a(unit = "J/kg", start = _h_in_port_a_start) "Prescribed specific enthalpy"
    annotation (Placement(transformation(extent={{-124,14},{-84,54}})));
    parameter Real _p_in_port_a_start = 100000.0
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput p_in_port_a(unit = "Pa", nominal = 100000.0, min = 611.657, max = 100000000.0, start = _p_in_port_a_start) "Prescribed pressure"
    annotation (Placement(transformation(extent={{-124,-20},{-84,20}})));
    parameter Real _m_in_port_b_start = 0.0
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput m_in_port_b(unit = "kg/s", min = -100000.0, max = 100000.0, start = _m_in_port_b_start) "Prescribed pressure"
    annotation (Placement(transformation(extent={{-124,-53},{-84,-13}})));
    parameter Real _h_in_port_b_start = 0.0
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput h_in_port_b(unit = "J/kg", start = _h_in_port_b_start) "Prescribed pressure"
    annotation (Placement(transformation(extent={{-124,-86},{-84,-46}})));
    Modelica.Blocks.Interfaces.RealOutput Power(unit = "W")
    annotation (Placement(transformation(extent={{100,62},{120,82}})));
    Modelica.Blocks.Interfaces.RealOutput freq(unit = "s-1")
    annotation (Placement(transformation(extent={{100,33},{120,53}})));
    Modelica.Blocks.Interfaces.RealOutput m_flow_out_port_a(unit = "kg/s", min = -100000.0, max = 100000.0)
    annotation (Placement(transformation(extent={{100,5},{120,25}})));
    Modelica.Blocks.Interfaces.RealOutput h_out_port_a(unit = "J/kg", nominal = 500000.0, min = -10000000000.0, max = 10000000000.0)
    annotation (Placement(transformation(extent={{100,-24},{120,-4}})));
    Modelica.Blocks.Interfaces.RealOutput p_out_port_b(unit = "Pa", nominal = 1000000.0, min = 611.657, max = 100000000.0)
    annotation (Placement(transformation(extent={{100,-52},{120,-32}})));
    Modelica.Blocks.Interfaces.RealOutput h_out_port_b(unit = "J/kg", nominal = 500000.0, min = -10000000000.0, max = 10000000000.0)
    annotation (Placement(transformation(extent={{100,-81},{120,-61}})));
  public
    parameter String fmi_instanceName="BOP_ME_fmu"
    annotation (Dialog(tab="FMI", group="Instance name"));
    parameter Boolean fmi_loggingOn=false
    annotation (Dialog(tab="FMI", group="Enable logging"));
    parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/resources")
    annotation (Dialog(tab="FMI", group="Instantiation"));
  protected
    constant Integer fmi_NumberOfEventIndicators = 60;
    Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
    Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
    fmi_Functions.fmiModel fmi;
    parameter Real zeroOffset = 0; //will fix in later implementations
    Boolean fmi_NewStates;
    Boolean fmi_StepEvent;
    Boolean fmi_DiscreteInputChanged;
    Boolean fmi_iterationConverged(start=false, fixed=true);
    Integer fmi_NextMode;
    Boolean fmi_flip(start=false, fixed=true);
    Real fmi_TNext(start=1e37, fixed=true);
    Real myTime;
    parameter Real myTimeStart(fixed=false);
    Boolean _first(start=true);
    parameter Boolean _startValuesNotSet(fixed=false,start=true);
    Real fmi_dummy;
  package fmi_Functions
      class fmiModel
        extends ExternalObject;
        function constructor "Initialize FMI model"
          extends Modelica.Icons.Function;
          input String instanceName;
          input Boolean loggingOn;
          input String resourceLocation;
          output fmiModel fmi;
          external"C" fmi = BOP_ME55251191451993994639_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
          annotation(Header="
#ifndef BOP_ME55251191451993994639_Instantiate_C
#define BOP_ME55251191451993994639_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void BOP_ME55251191451993994639Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * BOP_ME55251191451993994639_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&BOP_ME55251191451993994639Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"BOP_ME.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (BOP_ME.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmi2SetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2SetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmi2GetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2GetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmi2SetTimeFunc)GetProcAddress(res->hInst,\"fmi2SetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmi2CompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmi2CompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2CompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterEventMode=(fmi2EnterEventModeFunc)GetProcAddress(res->hInst,\"fmi2EnterEventMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterEventMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterEventMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiNewDiscreteStates=(fmi2NewDiscreteStatesFunc)GetProcAddress(res->hInst,\"fmi2NewDiscreteStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2NewDiscreteStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiNewDiscreteStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterContinuousTimeMode=(fmi2EnterContinuousTimeModeFunc)GetProcAddress(res->hInst,\"fmi2EnterContinuousTimeMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterContinuousTimeMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterContinuousTimeMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmi2GetDerivativesFunc)GetProcAddress(res->hInst,\"fmi2GetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmi2GetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmi2GetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDirectionalDerivative=(fmi2GetDirectionalDerivativeFunc)GetProcAddress(res->hInst,\"fmi2GetDirectionalDerivative\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDirectionalDerivative!\");
      return 0;
    }
    if (!(res->dyFmiGetFMUstate=(fmi2GetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2GetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSetFMUstate=(fmi2SetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiFreeFMUstate=(fmi2FreeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2FreeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSerializedFMUstateSize=(fmi2SerializedFMUstateSizeFunc)GetProcAddress(res->hInst,\"fmi2SerializedFMUstateSize\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializedFMUstateSize!\");
      return 0;
    }
    if (!(res->dyFmiSerializeFMUstate=(fmi2SerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiDeSerializeFMUstate=(fmi2DeSerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2DeSerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2DeSerializeFMUstate!\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2ModelExchange, \"{55c25d1e-191a-451a-9faf-f93ce99463f9}\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
        end constructor;

        function destructor "Release storage of FMI model"
          extends Modelica.Icons.Function;
          input fmiModel fmi;
          external"C"
                     BOP_ME55251191451993994639_fmiFreeModelInstance2(fmi);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_Free_C
#define BOP_ME55251191451993994639_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void BOP_ME55251191451993994639_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    if(a->dyFMUstate)
    a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
        end destructor;
      end fmiModel;

      function fmiSetTime
      input fmiModel fmi;
      input Real ti;
      external"C" BOP_ME55251191451993994639_fmiSetTime2(fmi, ti);
      annotation (Header="
#ifndef BOP_ME55251191451993994639_SetTime_C
#define BOP_ME55251191451993994639_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetTime2(void*m, double ti) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(ti > a->dyTime || (a->currentMode == dyfmi2EventMode && ti==a->dyTime && !isModelicaEvent())){
      a->dyTime=ti;
      if(a->currentMode == dyfmi2EventMode){
        status = a->dyFmiEnterContinuousTimeMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterContinuousTimeMode failed!\");
        a->currentMode = dyfmi2ContinuousTimeMode;
      }
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti < a->dyTime && a->currentMode == dyfmi2ContinuousTimeMode){
       a->dyTime=ti;
       status=a->dyFmiSetTime(a->m, ti);
    }else{
       status=fmi2OK;
    }
  }
  if (status!=fmi2OK ) ModelicaError(\"SetTime failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true);
      end fmiSetTime;

      function fmiSetContinuousStates
      input fmiModel fmi;
      input Real x[:];
        external"C" BOP_ME55251191451993994639_fmiSetContinuousStates2(
         fmi,
         x,
         size(x, 1));
        annotation (Header="
#ifndef BOP_ME55251191451993994639_SetContinuousStates_C
#define BOP_ME55251191451993994639_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
     status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
     status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetContinuousStates failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiSetContinuousStates;

      function fmiGetContinuousStates
      input fmiModel fmi;
      input Integer nx;
      output Real x[nx];
      input Real preAvailable;
        external"C" BOP_ME55251191451993994639_fmiGetContinuousStates2(
          fmi,
          x,
          nx);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetContinuousStates_C
#define BOP_ME55251191451993994639_GetContinuousStates_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void BOP_ME55251191451993994639_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetContinuousStates failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetContinuousStates;

      function fmiCompletedIntegratorStep
      input fmiModel fmi;
      input Real dummyTime;
      output Real crossing;
        external"C" crossing = BOP_ME55251191451993994639_fmiCompletedIntegratorStep2(fmi);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_CompletedIntegratorStep_C
#define BOP_ME55251191451993994639_CompletedIntegratorStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double BOP_ME55251191451993994639_fmiCompletedIntegratorStep2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status = fmi2Fatal;
  fmi2Boolean enterEventMode = fmi2False;
  fmi2Boolean terminateSimulation = fmi2False;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      status=a->dyFmiCompletedIntegratorStep(a->m, fmi2True, &enterEventMode, &terminateSimulation);
      if(terminateSimulation == fmi2True) terminate(\"Terminate signaled by FMU after call to fmiCompletedIntegratorStep\");
      a->dyLastTime=a->dyTime;
      if (enterEventMode == fmi2True) a->dyTriggered=1;
    } else status=fmi2OK;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiCompletedIntegratorStep;

      function fmiEnterModelInitialization
      input fmiModel fmi;
      input Real startTime;
      external"C" BOP_ME55251191451993994639_fmiEnterModelInitialization2(fmi, startTime);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiEnterModelInitialization_C
#define BOP_ME55251191451993994639_fmiEnterModelInitialization_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiEnterModelInitialization2(void*m, double startTime) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean toleranceControlled=fmi2False;
  fmi2Real tolerance=0;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      a->dyTime=startTime;
      status=a->dyFmiSetupExperiment(a->m, fmi2False, 0, a->dyTime, fmi2False, 0);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->currentMode=dyfmi2InitializationMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"Initialize failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiEnterModelInitialization;

      function fmiExitModelInitializationMode
      input fmiModel fmi;
      output Real dummy=1.0;
      external"C" BOP_ME55251191451993994639_fmiExitModelInitializationMode2(fmi);
      annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiExitModelInitializationMode_C
#define BOP_ME55251191451993994639_fmiExitModelInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiExitModelInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiExitModelInitializationMode;

      function fmiUpdateDiscreteStates
      input fmiModel fmi;
      output Integer nextMode;
      output Real tNext;
      output Boolean stateValuesChanged;
      external"C" nextMode = BOP_ME55251191451993994639_fmiUpdateDiscreteStates2(fmi, tNext, stateValuesChanged);
        annotation(Header="
#ifndef BOP_ME55251191451993994639_UpdateDiscreteStates_C
#define BOP_ME55251191451993994639_UpdateDiscreteStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
int BOP_ME55251191451993994639_fmiUpdateDiscreteStates2(void*m, double* tNext, int* stateValuesChanged){
  struct dy_fmi2Extended*a=m;
  fmi2EventInfo ev;
  fmi2Status status=fmi2Fatal;
  ev.nextEventTime=1e37;
  ev.newDiscreteStatesNeeded=fmi2False;
  ev.valuesOfContinuousStatesChanged=fmi2False;
  ev.nextEventTimeDefined=fmi2False;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
  status=a->dyFmiNewDiscreteStates(a->m, &ev);
  a->dyTriggered=0;
  a->dyLastTime=a->dyTime;
  a->discreteInputChanged=0;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"EventUpdate failed\");
  if (ev.terminateSimulation){
    terminate(\"Terminate signaled by FMU\");
  }
  if(ev.nextEventTimeDefined==fmi2True){
    *tNext=ev.nextEventTime;
  }else{
    *tNext=1e37;
  }
  *stateValuesChanged = ev.valuesOfContinuousStatesChanged;
  return ev.newDiscreteStatesNeeded;
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiUpdateDiscreteStates;

      function fmiGetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      external"C" BOP_ME55251191451993994639_fmiGetDerivatives2(
      fmi,
        dx,
        nx);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetDerivatives_C
#define BOP_ME55251191451993994639_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetDerivatives failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetDerivatives;

      function fmiGetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      external"C" BOP_ME55251191451993994639_fmiGetEventIndicators2(
        fmi,
        z,
        nz);
      annotation (Header="
#ifndef BOP_ME55251191451993994639_GetEventIndicators_C
#define BOP_ME55251191451993994639_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode || a->currentMode == dyfmi2EventMode){
      status=a->dyFmiGetEventIndicators(a->m, z, nz);
    }else{
      status=fmi2OK;    }
;  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetEventIndicators failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetEventIndicators;

      function fmiReset
        input fmiModel fmi;
        output Boolean resetOK;
        external"C" resetOK = BOP_ME55251191451993994639_fmiReset2(fmi);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_Reset_C
#define BOP_ME55251191451993994639_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double BOP_ME55251191451993994639_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiReset;

      function fmiGetRealScalar
        input fmiModel fmi;
        input Integer ref;
        output Real val;
      algorithm
          val := scalar(fmiGetReal(fmi, {ref}));
      end fmiGetRealScalar;

      function fmiGetReal
        input fmiModel fmi;
        input Integer refs[:];
        output Real vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetReal_C
#define BOP_ME55251191451993994639_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetReal;

      function fmiGetRealwf
        input fmiModel fmi;
        input Integer refs[:];
        input Real preAvailable;
        output Real vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetReal_C
#define BOP_ME55251191451993994639_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetRealwf;

      function fmiSetReal
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
        external"C"
                   BOP_ME55251191451993994639_fmiSetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_SetReal_C
#define BOP_ME55251191451993994639_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetReal;

      function fmiSetRealwf
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
        input Real preAvailable;
        output Real postAvailable=preAvailable;
        external"C"
                   BOP_ME55251191451993994639_fmiSetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_SetReal_C
#define BOP_ME55251191451993994639_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetRealwf;

      function fmiGetIntegerScalar
        input fmiModel fmi;
        input Integer ref;
        output Integer val;
      algorithm
          val := scalar(fmiGetInteger(fmi, {ref}));
      end fmiGetIntegerScalar;

      function fmiGetInteger
        input fmiModel fmi;
        input Integer refs[:];
        output Integer vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetInteger_C
#define BOP_ME55251191451993994639_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetInteger;

      function fmiGetIntegerwf
        input fmiModel fmi;
        input Integer refs[:];
        input Integer preAvailable;
        output Integer vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetInteger_C
#define BOP_ME55251191451993994639_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void BOP_ME55251191451993994639_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetIntegerwf;

      function fmiSetInteger
        input fmiModel fmi;
        input Integer refs[:];
        input Integer vals[size(refs, 1)];
      protected
        Integer oldVals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiSetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          oldVals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_SetInteger_C
#define BOP_ME55251191451993994639_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetInteger;

      function fmiGetBooleanScalar
        input fmiModel fmi;
        input Integer ref;
        output Boolean val;
      algorithm
          val := scalar(fmiGetBoolean(fmi, {ref}));
      end fmiGetBooleanScalar;

      function fmiGetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        output Boolean vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_GetBoolean_C
#define BOP_ME55251191451993994639_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetBoolean;

      function fmiGetBooleanwf
        input fmiModel fmi;
        input Integer refs[:];
        input Integer preAvailable;
        output Boolean vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiGetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_GetBoolean_C
#define BOP_ME55251191451993994639_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetBooleanwf;

      function fmiSetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        input Boolean vals[size(refs, 1)];
      protected
        Boolean dummy[size(refs, 1)];
        Boolean oldVals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiSetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          dummy,
          oldVals);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_SetBoolean_C
#define BOP_ME55251191451993994639_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetBoolean;

      function fmiSetString
        input fmiModel fmi;
        input Integer refs[:];
        input String vals[size(refs, 1)];
        external"C" BOP_ME55251191451993994639_fmiSetString2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_SetString_C
#define BOP_ME55251191451993994639_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetString;

      function fmiGetDirectionalDerivative
        input fmiModel fmi;
        input Integer z_refs[:];
        input Integer v_refs[:];
        input Real dv[size(v_refs, 1)];
        output Real dz[size(z_refs, 1)];
        external"C" BOP_ME55251191451993994639_GetDirectionalDerivative2(
          fmi,
          z_refs,
          size(z_refs, 1),
          v_refs,
          size(v_refs, 1),
          dv,
          dz);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_GetDirectionalDerivative2_C
#define BOP_ME55251191451993994639_GetDirectionalDerivative2_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_GetDirectionalDerivative2(void*m, const int* zref, size_t nzr, const int* vrefs, size_t nvr, const double *dv, double *dz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDirectionalDerivative(a->m, zref, nzr, vrefs, nvr, dv, dz);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetDirectionalDerivative failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiGetDirectionalDerivative;

      function CheckIfDiscreteValueSet
        input fmiModel fmi;
        input Real dummyTime;
        input Real realInputs[:];
        input Boolean booleanInputs[:];
        input Integer integerInputs[:];
        input Integer realInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Real dummyRealOutputs[:];
        input Boolean dummyBooleanOutputs[:];
        input Integer dummyIntegerOutputs[:];
        output Real DiscreteInputSet;
      algorithm
        fmiSetReal(fmi, realInputValueReferences, realInputs);
        fmiSetBoolean(fmi, booleanInputValueReferences, booleanInputs);
        fmiSetInteger(fmi, integerInputValueReferences, integerInputs);
        DiscreteInputSet := fmiCheckIfDiscreteValueSet(fmi);
        annotation(LateInline=true);
      end CheckIfDiscreteValueSet;

      function fmiCheckIfDiscreteValueSet
        input fmiModel fmi;
        output Real DiscreteInputSet;
        external "C" DiscreteInputSet = BOP_ME55251191451993994639_fmiCheckIfDiscreteValueSet2(fmi);
        annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiCheckIfDiscreteValueSet_C
#define BOP_ME55251191451993994639_fmiCheckIfDiscreteValueSet_C 1
#include \"FMI/fmi2Import.h\"
double BOP_ME55251191451993994639_fmiCheckIfDiscreteValueSet2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    return a->discreteInputChanged;
  }
  ModelicaError(\"fmiCheckIfDiscreteValueSet2 failed!\");
  return 0;
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiCheckIfDiscreteValueSet;

      function GetEventIndicators
        input fmiModel fmi;
        input Integer nz;
        output Real z[nz];
        input Real dummyTime;
        input Real realInputs[:];
        input Boolean booleanInputs[:];
        input Integer integerInputs[:];
        //input String stringInputs[:];
        input Integer realInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        //input Integer stringInputVariableReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        z := fmiGetEventIndicators(fmi, nz);
        annotation(LateInline=true);
      end GetEventIndicators;

      function noHysteresis
        input Real x;
        output Real y;
      algorithm
        y:=x+(if (x < 0) then -1 else 1);
      end noHysteresis;

      function GetRealVariable
        input fmiModel fmi;
        input Real Time;
        input Real realInputs[:];
        input Real realLinearDependentInputs[:];
        input Real states[:];
        input Real linearDependentStates[:];
        input Real linearOffset=0;
        input Boolean booleanInputs[:];
        input Integer integerInputs[:];
        //input String stringInputs[:];
        input Integer realInputValueReferences[:];
        input Integer realLinearDependentInputsValueReferences[:];
        input Integer statesValueRefernces[:];
        input Integer booleanInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        //input Integer stringInputValueReferences[:];
        input Integer outputValueReference[:];
        output Real outputVariable;
      algorithm
        //fmi_Functions.fmiSetTime(fmi, Time);
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        //SetString(fmi,stringInputValueReferences,stringInputs);
        outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
        annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable, LateInline=true);
      end GetRealVariable;

      function derGetRealVariable
        input fmiModel fmi;
        input Real Time;
        input Real realInputs[:];
        input Real realLinearDependentInputs[:];
        input Real states[:];
        input Real linearDependentStates[:];
        input Real linearOffset=0;
        input Boolean booleanInputs[:];
        input Integer integerInputs[:];
        //input String stringInputs[:];
        input Integer realInputValueReferences[:];
        input Integer realLinearDependentInputsValueReferences[:];
        input Integer statesValueRefernces[:];
        input Integer booleanInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        //input Integer stringInputValueReferences[:];
        input Integer outputValueReference[:];
        input Real derRealInputs[:];
        input Real derStates[:];
        input Real derLinearOffsets;
        output Real derOutputVariable;
      protected
        Real dummy[1];
      algorithm
        //fmi_Functions.fmiSetTime(fmi, Time);
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        //setString(fmi,stringInputValueReferences,stringInputs);
        dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
        derOutputVariable:=dummy[1]+derLinearOffsets;
        annotation(LateInline=true);
      end derGetRealVariable;

      function fmiSaveFMUState
        input fmiModel fmi;
        external"C" BOP_ME55251191451993994639_fmiSaveFMUState2(fmi);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiSaveFMUState_C
#define BOP_ME55251191451993994639_fmiSaveFMUState_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSaveFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiSaveFMUState;

      function fmiRestoreFMUState
        input fmiModel fmi;
        external"C" BOP_ME55251191451993994639_fmiRestoreFMUState2(fmi);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiRestoreFMUState_C
#define BOP_ME55251191451993994639_fmiRestoreFMUState_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiRestoreFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiRestoreFMUState;

      function fmiSerializeFMUstate
        input fmiModel fmi;
        external"C" BOP_ME55251191451993994639_fmiSerializeFMUstate2(fmi);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiSerializeFMUstate_C
#define BOP_ME55251191451993994639_fmiSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
    status = a->dyFmiSerializedFMUstateSize(a->m, a->dyFMUstate, &a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializedFMUstateSize failed\");
    if( a->dySerializeFMUstate) free(a->dySerializeFMUstate); a->dySerializeFMUstate = NULL;
    a->dySerializeFMUstate = malloc(a->dyFMUStateSize);
    if(!a->dySerializeFMUstate)  ModelicaError(\"malloc call to allocate SerializeFMUstate failed\");
    status = a->dyFmiSerializeFMUstate(a->m, a->dyFMUstate, a->dySerializeFMUstate, a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializeFMUstate failed\");
  }
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiSerializeFMUstate;

      function fmiDeSerializeFMUstate
        input fmiModel fmi;
        external"C" BOP_ME55251191451993994639_fmiDeSerializeFMUstate2(fmi);
          annotation (Header="
#ifndef BOP_ME55251191451993994639_fmiDeSerializeFMUstate_C
#define BOP_ME55251191451993994639_fmiDeSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void BOP_ME55251191451993994639_fmiDeSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(!a->dySerializeFMUstate) ModelicaError(\"serializedFmuState is not allocated!!!\");
    if(a->dyFMUstate){
      a->dyFmiFreeFMUstate(a->m, a->dyFMUstate);
      a->dyFMUstate = NULL;    }
    status = a->dyFmiDeSerializeFMUstate(a->m, a->dySerializeFMUstate, a->dyFMUStateSize, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiDeSerializeFMUstate failed\");
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
  }
}
#endif",   Library="BOP_ME", LibraryDirectory="modelica://BOP_ME_fmu/Resources/Library/FMU/BOP_ME/binaries", __Dymola_CriticalRegion="BOP_ME");
      end fmiDeSerializeFMUstate;

      function setTimeAndStates
        input fmiModel fmu;
        input Real Time;
        input Real States[:];
        input Real dummy;
        output Real tOut=Time;
      algorithm
        fmiSetTime(fmu, Time);
        fmiSetContinuousStates(fmu,States);
        annotation(derivative(noDerivative=dummy,noDerivative=States)=dTS);
      end setTimeAndStates;

      function dTS
        input fmiModel fmu;
        input Real Time;
        input Real States[:];
        input Real dummy;
        input Real dTime;
        output Real dt;
      algorithm
        dt:=1;
        annotation(derivative(order=2)=ddTS);
      end dTS;

      function ddTS
        input fmiModel fmu;
        input Real Time;
        input Real States[:];
        input Real dummy;
        input Real dTime;
        input Real ddTime;
        output Real ddt;
      algorithm
        ddt:=0;
      end ddTS;
  end fmi_Functions;
  algorithm
    when initial() then
      if _first then
        _first := false;
        fmi := fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
      end if;
    end when;
  initial algorithm
    if _startValuesNotSet then
    fmi_Functions.fmiSetReal(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777293, 16777294, 16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777230, 16777231, 16777232, 16777233, 16777234, 16777235, 16777236, 16777237, 16777238, 16777239, 16777240, 16777241, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777257, 16777258, 16777259, 16777260, 16777261, 16777262, 16777263, 16777264, 16777265, 16777266, 16777267, 16777268, 16777269, 16777270, 16777271, 16777272, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777295, 16777296, 16777297, 16777299, 16777300, 16777301, 16777298, 16777302, 16777304, 16777308, 16777309, 16777312, 16777313, 16777314, 16777315, 16777316, 16777318, 16777321, 16777323, 16777324, 16777325}, {'system'.p_ambient, 'system'.T_ambient, 'system'.g, 'system'.m_flow_start, 'system'.eps_m_flow, 'system'.dp_small, 'system'.m_flow_small, BOP.'port_a3_nominal_m_flow[1]', BOP.p_condenser, BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.Ti, BOP.CS.PID_TCV_opening.Td, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.k_ff, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.wd, BOP.CS.PID_TCV_opening.Ni, BOP.CS.PID_TCV_opening.Nd, BOP.CS.PID_TCV_opening.xd_start, BOP.CS.PID_TCV_opening.y_start, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.addI.k1, BOP.CS.PID_TCV_opening.addI.k2, BOP.CS.PID_TCV_opening.addI.k3, BOP.CS.PID_TCV_opening.addSat.k1, BOP.CS.PID_TCV_opening.addSat.k2, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.Ti, BOP.CS.PID_BV_opening.Td, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.k_ff, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.wd, BOP.CS.PID_BV_opening.Ni, BOP.CS.PID_BV_opening.Nd, BOP.CS.PID_BV_opening.xd_start, BOP.CS.PID_BV_opening.y_start, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.addI.k1, BOP.CS.PID_BV_opening.addI.k2, BOP.CS.PID_BV_opening.addI.k3, BOP.CS.PID_BV_opening.addSat.k1, BOP.CS.PID_BV_opening.addSat.k2, BOP.CS.PID_BV_opening.Dzero.k, BOP.CS.BV_opening.k1, BOP.CS.BV_opening.k2, BOP.CS.BV_diffopeningNominal.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.steamTurbine.'taus[1]', BOP.steamTurbine.'taus[2]', BOP.steamTurbine.eta_mech, BOP.steamTurbine.'X_start[1]', BOP.steamTurbine.partialArc_nominal, BOP.steamTurbine.Kt_constant, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.generator1.eta, BOP.generator1.f_start, BOP.condenser.V_total, BOP.volume.'X_start[1]', BOP.reservoir.A, BOP.reservoir.V0, BOP.reservoir.level_start, BOP.reservoir.h_start, BOP.reservoir.'X_start[1]', BOP.feedWaterHeater.'X_start[1]', BOP.boundary.Q_flow, BOP.PID.k, BOP.PID.Ti, BOP.PID.Td});
    fmi_Functions.fmiSetReal(fmi, {16777326, 16777327, 16777328, 16777329, 16777330, 16777331, 16777332, 16777333, 16777334, 16777335, 16777336, 16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 16777344, 16777345, 16777346, 16777347, 16777348, 16777349, 16777357, 16777358, 16777359, 16777360, 16777361, 16777362, 16777363, 16777364, 16777370, 16777371, 16777372, 16777373, 16777374, 16777375, 16777376, 16777377, 16777386, 16777389, 16777392, 16777393, 16777394, 16777395, 16777396, 16777397, 16777398, 16777399, 16777400, 16777401, 16777402, 16777403, 16777405, 16777406, 16777407, 16777408, 16777409, 16777410, 16777411, 16777412, 16777413, 16777414, 16777415, 16777416, 16777417, 16777418, 16777419, 16777420, 16777422, 16777423, 16777424, 16777425, 16777426, 16777427, 16777428, 16777429}, {BOP.PID.yb, BOP.PID.k_ff, BOP.PID.yMax, BOP.PID.wp, BOP.PID.wd, BOP.PID.Ni, BOP.PID.Nd, BOP.PID.xd_start, BOP.PID.y_start, BOP.PID.addP.k2, BOP.PID.P.k, BOP.PID.addPID.k1, BOP.PID.addPID.k2, BOP.PID.addPID.k3, BOP.PID.Fzero.k, BOP.PID.addFF.k1, BOP.PID.addFF.k2, BOP.PID.addFF.k3, BOP.PID.addI.k1, BOP.PID.addI.k2, BOP.PID.addI.k3, BOP.PID.addSat.k1, BOP.PID.addSat.k2, BOP.PID.Dzero.k, BOP.valve_BV.Kv, BOP.valve_BV.Cv, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.riseTime, BOP.valve_BV.leakageOpening, BOP.valve_BV.Fxt_full, BOP.volume_bypass.'X_start[1]', BOP.valve_TCV.Kv, BOP.valve_TCV.Cv, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.riseTime, BOP.valve_TCV.leakageOpening, BOP.valve_TCV.Fxt_full, BOP.header.'X_start[1]', BOP.'massFlowRate[1]'.m_flow_small, BOP.'specificEnthalpy[1]'.m_flow_small, BOP.PID1.k, BOP.PID1.Ti, BOP.PID1.Td, BOP.PID1.yb, BOP.PID1.yMax, BOP.PID1.yMin, BOP.PID1.wp, BOP.PID1.wd, BOP.PID1.Ni, BOP.PID1.Nd, BOP.PID1.xd_start, BOP.PID1.y_start, BOP.PID1.PID.k_ff, BOP.PID1.PID.addP.k2, BOP.PID1.PID.P.k, BOP.PID1.PID.addPID.k1, BOP.PID1.PID.addPID.k2, BOP.PID1.PID.addPID.k3, BOP.PID1.PID.Fzero.k, BOP.PID1.PID.addFF.k1, BOP.PID1.PID.addFF.k2, BOP.PID1.PID.addFF.k3, BOP.PID1.PID.addI.k1, BOP.PID1.PID.addI.k2, BOP.PID1.PID.addI.k3, BOP.PID1.PID.addSat.k1, BOP.PID1.PID.addSat.k2, BOP.PID1.PID.Dzero.k, sinkElec.f, source1.m_flow, source1.h, source1.'X[1]', massFlowToPressure.h0_causal, massFlowToPressure.h0_acausal, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal});
    fmi_Functions.fmiSetBoolean(fmi, {16777306, 16777307, 16777311, 16777317, 16777320, 16777322, 16777350, 16777352, 16777353, 16777355, 16777356, 16777366, 16777367, 16777368, 16777369, 16777379, 16777380, 16777381, 16777382, 16777383, 16777384, 16777385, 16777388, 16777391, 16777404, 16777421}, {BOP.resistance.showName, BOP.condenser.showName, BOP.volume.showName, BOP.reservoir.showName, BOP.feedWaterHeater.showName, BOP.boundary.showName, BOP.temperature.showName, BOP.resistance1.showName, BOP.pressure.showName, BOP.valve_BV.showDesignFlowDirection, BOP.valve_BV.showName, BOP.volume_bypass.showName, BOP.resistance3.showName, BOP.valve_TCV.showDesignFlowDirection, BOP.valve_TCV.showName, BOP.header.showName, BOP.resistance4.showName, BOP.'boundary_a3[1]'.showName, BOP.'checkValve[1]'.showDesignFlowDirection, BOP.'checkValve[1]'.showName, BOP.'boundary_m_flow_a3[1]'.showName, BOP.'massFlowRate[1]'.showName, BOP.'specificEnthalpy[1]'.showName, BOP.resistance2.showName, BOP.PID1.pre_y_start, BOP.boundary2.showName});
    fmi_Functions.fmiSetInteger(fmi, {16777303, 16777305, 16777351, 16777354, 16777387, 16777390}, {BOP.generator1.nPoles, BOP.sensorW.precision, BOP.temperature.precision, BOP.pressure.precision, BOP.'massFlowRate[1]'.precision, BOP.'specificEnthalpy[1]'.precision});
    fmi_Functions.fmiSetReal(fmi, {33554434}, {BOP.steamTurbine._phi_start});
    fmi_Functions.fmiSetReal(fmi, {352321536, 352321537, 352321538, 352321539, 352321540}, {_BOP_Demand_start, _h_in_port_a_start, _p_in_port_a_start, _m_in_port_b_start, _h_in_port_b_start});
    fmi_Functions.fmiEnterModelInitialization(fmi, time);
    _startValuesNotSet :=false;
    end if;
    myTimeStart := time;
  initial equation
  equation
    when not initial() then
      fmi_dummy = fmi_Functions.fmiExitModelInitializationMode(fmi);
    {'system'.p_start, 'system'.T_start, 'system'.m_flow_nominal, BOP.'port_a3_nominal_T[1]', BOP.'port_a3_nominal_h[1]', BOP.'port_a3_start_T[1]', BOP.'port_a3_start_h[1]', BOP.'port_a3_start_m_flow[1]', BOP.CS.delayStartBV, BOP.CS.TCV_openingNominal.k, BOP.CS.switch_BV.u3, BOP.CS.BV_openingNominal.k, BOP.CS.greater5.u2, BOP.CS.PID_TCV_opening.u_m, BOP.CS.PID_TCV_opening.yMax, BOP.CS.PID_TCV_opening.yMin, BOP.CS.PID_TCV_opening.addP.u2, BOP.CS.PID_TCV_opening.addP.k1, BOP.CS.PID_TCV_opening.gainPID.k, BOP.CS.PID_TCV_opening.addPID.u2, BOP.CS.PID_TCV_opening.limiter.uMax, BOP.CS.PID_TCV_opening.limiter.uMin, BOP.CS.PID_TCV_opening.Fzero.y, BOP.CS.PID_TCV_opening.addFF.u3, BOP.CS.PID_TCV_opening.gain_u_s.k, BOP.CS.PID_TCV_opening.gain_u_m.k, BOP.CS.PID_TCV_opening.I.k, BOP.CS.PID_TCV_opening.gainTrack.k, BOP.CS.switch_TCV_setpoint.u3, BOP.CS.valvedelayBV.k, BOP.CS.PID_BV_opening.yMax, BOP.CS.PID_BV_opening.yMin, BOP.CS.PID_BV_opening.addP.k1, BOP.CS.PID_BV_opening.gainPID.k, BOP.CS.PID_BV_opening.addPID.u2, BOP.CS.PID_BV_opening.limiter.uMax, BOP.CS.PID_BV_opening.limiter.uMin, BOP.CS.PID_BV_opening.Fzero.y, BOP.CS.PID_BV_opening.addFF.u3, BOP.CS.PID_BV_opening.gain_u_s.k, BOP.CS.PID_BV_opening.gain_u_m.k, BOP.CS.PID_BV_opening.I.k, BOP.CS.PID_BV_opening.gainTrack.k, BOP.port_a_nominal.T, BOP.port_a_nominal.h, BOP.port_b_nominal.T, BOP.port_b_nominal.h, BOP.port_b_nominal.m_flow, BOP.port_a_start.p, BOP.port_a_start.T, BOP.port_a_start.h, BOP.port_a_start.m_flow, BOP.port_b_start.T, BOP.port_b_start.h, BOP.port_b_start.m_flow, BOP.'port_a3[1]'.m_flow, BOP.'port_a3[1]'.p, BOP.'port_a3[1]'.h_outflow, BOP.portElec_b.f, BOP.steamTurbine.'Q_units_start[1]', BOP.steamTurbine.'Q_units_start[2]', BOP.steamTurbine.p_a_start, BOP.steamTurbine.p_b_start, BOP.steamTurbine.T_a_start, BOP.steamTurbine.T_b_start, BOP.steamTurbine.h_a_start, BOP.steamTurbine.h_b_start, BOP.steamTurbine.m_flow_start, BOP.steamTurbine.eta_is, BOP.steamTurbine.m_flow_nominal, BOP.steamTurbine.p_inlet_nominal, BOP.steamTurbine.p_outlet_nominal, BOP.steamTurbine.T_nominal, BOP.steamTurbine.d_nominal, BOP.generator1.omega_e, BOP.resistance.port_a.h_outflow, BOP.resistance.port_b.p, BOP.condenser.V_liquid_start, BOP.condenser.h_fsat, BOP.condenser.rho_fsat, BOP.condenser.rho_gsat, BOP.condenser.sat.Tsat, BOP.volume.p_start, BOP.volume.h_start, BOP.feedWaterHeater.h_start, BOP.PID.k_s, BOP.PID.k_m, BOP.PID.yMin, BOP.PID.addP.u1, BOP.PID.addP.k1, BOP.PID.gainPID.k, BOP.PID.addPID.u2, BOP.PID.limiter.uMax, BOP.PID.limiter.uMin, BOP.PID.Fzero.y, BOP.PID.addFF.u3, BOP.PID.gain_u_s.k, BOP.PID.gain_u_m.k, BOP.PID.I.k, BOP.PID.gainTrack.k} = fmi_Functions.fmiGetRealwf(fmi, {100663302, 100663303, 100663305, 100663427, 100663428, 100663438, 100663439, 100663440, 100663309, 100663310, 234881098, 100663314, 100663317, 100663409, 100663324, 100663325, 100663332, 100663334, 100663336, 234881064, 100663339, 100663340, 234881055, 100663347, 100663345, 100663346, 100663353, 100663362, 234881065, 100663365, 100663370, 100663371, 100663380, 100663382, 234881095, 100663385, 100663386, 234881086, 100663393, 100663391, 100663392, 100663399, 100663408, 100663420, 100663421, 100663423, 100663424, 100663425, 100663429, 100663430, 100663431, 100663432, 100663434, 100663435, 100663436, 234881231, 100664084, 100663917, 234881230, 100663456, 100663457, 100663458, 100663459, 100663461, 100663462, 100663463, 100663464, 100663465, 234881106, 100663500, 100663503, 100663504, 100663506, 100663507, 100663514, 100663519, 100663530, 100663532, 100663529, 100663535, 100663536, 100663534, 100663552, 100663555, 100663627, 100663663, 100663664, 100663665, 100663671, 100663674, 100663676, 234881157, 100663679, 100663680, 234881148, 100663688, 100663685, 100663687, 100663694, 100663703}, fmi_dummy);
    {BOP.temperature.port.h_outflow, BOP.pressure.port.h_outflow, BOP.valve_BV.dp_start, BOP.valve_BV.m_flow_start, BOP.valve_BV.m_flow_small, BOP.valve_BV.m_flow_nominal, BOP.valve_BV.rho_nominal, BOP.valve_BV.dp_small, BOP.valve_BV.p_nominal, BOP.valve_BV.Fxt, BOP.volume_bypass.p_start, BOP.volume_bypass.h_start, BOP.valve_TCV.dp_start, BOP.valve_TCV.m_flow_start, BOP.valve_TCV.m_flow_small, BOP.valve_TCV.m_flow_nominal, BOP.valve_TCV.rho_nominal, BOP.valve_TCV.dp_small, BOP.valve_TCV.p_nominal, BOP.valve_TCV.Fxt, BOP.header.p_start, BOP.header.h_start, BOP.'boundary_a3[1]'.medium.d, BOP.'boundary_a3[1]'.medium.T, BOP.'boundary_a3[1]'.medium.u, BOP.'boundary_a3[1]'.medium.T_degC, BOP.'checkValve[1]'.m_flow_start, BOP.'checkValve[1]'.port_b.h_outflow, BOP.'boundary_m_flow_a3[1]'.h, BOP.'boundary_m_flow_a3[1]'.h_in, BOP.'boundary_m_flow_a3[1]'.medium.d, BOP.'boundary_m_flow_a3[1]'.medium.T, BOP.'boundary_m_flow_a3[1]'.medium.u, BOP.'boundary_m_flow_a3[1]'.medium.T_degC, BOP.'boundary_m_flow_a3[1]'.medium.p_bar, BOP.'boundary_m_flow_a3[1]'.medium.sat.Tsat, BOP.'boundary_m_flow_a3[1]'.'ports[1]'.m_flow, BOP.'boundary_m_flow_a3[1]'.'ports[1]'.p, BOP.PID1.u_s, BOP.PID1.k_s, BOP.PID1.k_m, BOP.PID1.eOn, BOP.PID1.eOff, BOP.PID1.PID.k, BOP.PID1.PID.Ti, BOP.PID1.PID.Td, BOP.PID1.PID.yb, BOP.PID1.PID.k_s, BOP.PID1.PID.k_m, BOP.PID1.PID.yMax, BOP.PID1.PID.yMin, BOP.PID1.PID.wp, BOP.PID1.PID.wd, BOP.PID1.PID.Ni, BOP.PID1.PID.Nd, BOP.PID1.PID.xd_start, BOP.PID1.PID.y_start, BOP.PID1.PID.addP.k1, BOP.PID1.PID.gainPID.k, BOP.PID1.PID.addPID.u2, BOP.PID1.PID.limiter.uMax, BOP.PID1.PID.limiter.uMin, BOP.PID1.PID.Fzero.y, BOP.PID1.PID.addFF.u3, BOP.PID1.PID.gain_u_s.k, BOP.PID1.PID.gain_u_m.k, BOP.PID1.PID.I.k, BOP.PID1.PID.gainTrack.k, BOP.PID1.hys.uLow, BOP.PID1.hys.uHigh, BOP.boundary2.medium.h, BOP.boundary2.medium.d, BOP.boundary2.medium.T, BOP.boundary2.medium.u, BOP.boundary2.medium.T_degC, source1.medium.d, source1.medium.T, source1.medium.u, source1.medium.T_degC, source1.medium.p_bar, source1.medium.sat.Tsat, source1.'ports[1]'.m_flow, source1.'ports[1]'.h_outflow, pressureToMassFlow.p_atm} = fmi_Functions.fmiGetRealwf(fmi, {100663706, 100663721, 100663724, 100663725, 100663726, 100663741, 100663742, 100663745, 100663750, 234881171, 100663766, 100663769, 100663806, 100663807, 100663808, 100663823, 100663824, 100663827, 100663832, 234881184, 100663854, 100663857, 100663896, 100663897, 100663899, 100663906, 100663926, 234881232, 100663951, 100663944, 100663930, 100663931, 100663933, 100663939, 100663940, 100663941, 100663942, 100663943, 234881122, 100663966, 100663967, 100663971, 100663972, 100663979, 100663980, 100663981, 100663982, 100663983, 100663984, 100663985, 100663986, 100663987, 100663988, 100663989, 100663990, 100663993, 100663994, 100664001, 100664003, 234881228, 100664006, 100664007, 234881219, 100664014, 100664012, 100664013, 100664020, 100664029, 100664030, 100664031, 100664057, 100664041, 100664042, 100664044, 100664051, 100664071, 100664072, 100664074, 100664080, 100664081, 100664082, 100664083, 100664085, 100664101}, fmi_dummy);
    {BOP.'boundary_a3[1]'.medium.phase, BOP.'boundary_m_flow_a3[1]'.medium.phase, BOP.boundary2.medium.phase, source1.medium.phase} = fmi_Functions.fmiGetIntegerwf(fmi, {100663902, 100663936, 100664047, 100664077}, integer(fmi_dummy));
    {BOP.PID1.hys.pre_y_start} = fmi_Functions.fmiGetBooleanwf(fmi, {100664032}, integer(fmi_dummy));
    end when;
    myTime = fmi_Functions.setTimeAndStates(fmi, time, {BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.phi, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]', BOP.condenser.V_liquid, BOP.volume.medium.p, BOP.volume.medium.h, BOP.reservoir.level, BOP.reservoir.h, BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.PID.I.y, BOP.volume_bypass.medium.p, BOP.volume_bypass.medium.h, BOP.header.medium.p, BOP.header.medium.h, BOP.PID1.PID.I.y}, fmi_dummy);
    fmi_StepEvent = fmi_Functions.fmiCompletedIntegratorStep(fmi, myTime)>0.5;
    fmi_DiscreteInputChanged= fmi_Functions.CheckIfDiscreteValueSet(fmi, myTime, {BOP_Demand, h_in_port_a, p_in_port_a, m_in_port_b, h_in_port_b}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540}, fill(0,0), fill(0,0), {Power, freq, m_flow_out_port_a, h_out_port_a, p_out_port_b, h_out_port_b}, fill(false,0), fill(0,0))  > 0.5;
    fmi_flip = ( if ( fmi_DiscreteInputChanged or not pre(fmi_iterationConverged)) then not pre(fmi_flip) else pre(fmi_flip));
    fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {BOP_Demand, h_in_port_a, p_in_port_a, m_in_port_b, h_in_port_b}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540}, fill(0,0), fill(0,0));
    for i in 1:size(fmi_z,1) loop
      fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
    end for;
    when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_flip, not fmi_flip, fmi_StepEvent}) then
      (fmi_NextMode, fmi_TNext, fmi_NewStates) =  fmi_Functions.fmiUpdateDiscreteStates(fmi);
      fmi_iterationConverged = if fmi_NextMode == 0 then true else false;
  {BOP.volume.medium.phase, BOP.feedWaterHeater.medium.phase, BOP.volume_bypass.medium.phase, BOP.header.medium.phase} = fmi_Functions.fmiGetIntegerwf(fmi, {637534476, 637534547, 637534690, 637534777}, if initial() then integer(myTimeStart) else integer(myTime));
  {BOP.CS.switch_BV.u2, BOP.CS.greater5.y, BOP.PID1.hys.y} = fmi_Functions.fmiGetBooleanwf(fmi, {637534224, 637534228, 637534946}, if initial() then integer(myTimeStart) else integer(myTime));
    end when;
  initial equation
    BOP.CS.PID_TCV_opening.I.y = fmi_Functions.fmiGetRealScalar(fmi,33554432);
    BOP.CS.PID_BV_opening.I.y = fmi_Functions.fmiGetRealScalar(fmi,33554433);
    BOP.feedWaterHeater.medium.p = fmi_Functions.fmiGetRealScalar(fmi,33554442);
    BOP.PID.I.y = fmi_Functions.fmiGetRealScalar(fmi,33554444);
    BOP.PID1.PID.I.y = fmi_Functions.fmiGetRealScalar(fmi,33554449);
  initial equation
    BOP.steamTurbine.'Q_units[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.valve_TCV.dp_nominal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777292, 16777294, 16777372}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554435});
    BOP.steamTurbine.'Q_units[2]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.valve_TCV.dp_nominal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777292, 16777294, 16777372}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554436});
    BOP.steamTurbine.Kt = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.valve_TCV.dp_nominal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777292, 16777294, 16777372}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {100663508});
    BOP.condenser.V_liquid = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.condenser.V_total}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777308}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554437});
    BOP.volume.medium.p = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.p_condenser}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777294}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554438});
    BOP.volume.medium.h = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.p_condenser, BOP.valve_TCV.dp_nominal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777294, 16777372}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554439});
    BOP.reservoir.level = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.reservoir.level_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554440});
    BOP.reservoir.h = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.reservoir.h_start}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777315}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554441});
    BOP.feedWaterHeater.medium.h = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554443});
    BOP.valve_BV.Av = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777292, 16777359, 16777360, 16777363}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {100663740});
    BOP.volume_bypass.medium.p = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.p_condenser}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777294}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554445});
    BOP.volume_bypass.medium.h = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554446});
    BOP.valve_TCV.Av = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777292, 16777372, 16777373, 16777376}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {100663822});
    BOP.header.medium.p = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554447});
    BOP.header.medium.h = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554448});
  equation
    if initial() then
      der(BOP.CS.PID_TCV_opening.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.Ti, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.Ni, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.addI.k1, BOP.CS.PID_TCV_opening.addI.k2, BOP.CS.PID_TCV_opening.addI.k3, BOP.CS.PID_TCV_opening.addSat.k1, BOP.CS.PID_TCV_opening.addSat.k2, BOP.CS.PID_TCV_opening.Dzero.k, BOP.port_a_nominal.p}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777223, 16777224, 16777225, 16777227, 16777228, 16777229, 16777230, 16777232, 16777233, 16777234, 16777236, 16777238, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777251, 16777252, 16777253, 16777254, 16777255, 16777256, 16777291}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202560});
    else
      der(BOP.CS.PID_TCV_opening.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.header.medium.p}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554447}, fill(0,0), fill(0,0), {587202560});
    end if;
    if initial() then
      der(BOP.CS.PID_BV_opening.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.Ti, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.Ni, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.I.y, BOP.CS.PID_BV_opening.addI.k1, BOP.CS.PID_BV_opening.addI.k2, BOP.CS.PID_BV_opening.addI.k3, BOP.CS.PID_BV_opening.addSat.k1, BOP.CS.PID_BV_opening.addSat.k2, BOP.CS.PID_BV_opening.Dzero.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.generator1.eta, BOP.valve_TCV.dp_nominal, sinkElec.f, BOP_Demand}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777223, 16777226, 16777227, 16777228, 16777260, 16777261, 16777263, 16777264, 16777265, 16777267, 16777269, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 33554433, 16777282, 16777283, 16777284, 16777285, 16777286, 16777287, 16777291, 16777292, 16777294, 16777302, 16777372, 16777422, 352321536}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {587202561});
    else
      der(BOP.CS.PID_BV_opening.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, {BOP_Demand}, fill(0.0,0), {BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554433, 33554435, 33554436}, fill(0,0), fill(0,0), {587202561});
    end if;
    if initial() then
      der(BOP.steamTurbine.phi) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {sinkElec.f}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777422}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {318767106});
    else
      der(BOP.steamTurbine.phi) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {318767106});
    end if;
    if initial() then
      der(BOP.steamTurbine.'Q_units[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.'taus[1]', BOP.steamTurbine.eta_mech, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777223, 16777224, 16777225, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777291, 16777292, 16777294, 16777295, 16777297, 16777298, 16777300, 16777372, 16777373, 16777376}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202563});
    else
      der(BOP.steamTurbine.'Q_units[1]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.volume.medium.p, BOP.volume.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554435, 33554438, 33554439, 33554447, 33554448}, fill(0,0), fill(0,0), {587202563});
    end if;
    if initial() then
      der(BOP.steamTurbine.'Q_units[2]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.'taus[2]', BOP.steamTurbine.eta_mech, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777223, 16777224, 16777225, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777291, 16777292, 16777294, 16777296, 16777297, 16777298, 16777300, 16777372, 16777373, 16777376}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202564});
    else
      der(BOP.steamTurbine.'Q_units[2]') = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.steamTurbine.'Q_units[2]', BOP.volume.medium.p, BOP.volume.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554436, 33554438, 33554439, 33554447, 33554448}, fill(0,0), fill(0,0), {587202564});
    end if;
    if initial() then
      der(BOP.condenser.V_liquid) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.p_condenser}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777294}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202565});
    else
      der(BOP.condenser.V_liquid) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202565});
    end if;
    if initial() then
      der(BOP.volume.medium.p) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777223, 16777224, 16777225, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777291, 16777292, 16777294, 16777298, 16777300, 16777372, 16777373, 16777376}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202566});
    else
      der(BOP.volume.medium.p) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.volume.medium.p, BOP.volume.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554438, 33554439, 33554447, 33554448}, fill(0,0), fill(0,0), {587202566});
    end if;
    if initial() then
      der(BOP.volume.medium.h) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777223, 16777224, 16777225, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777291, 16777292, 16777294, 16777298, 16777300, 16777372, 16777373, 16777376}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202567});
    else
      der(BOP.volume.medium.h) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.volume.medium.p, BOP.volume.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554438, 33554439, 33554447, 33554448}, fill(0,0), fill(0,0), {587202567});
    end if;
    if initial() then
      der(BOP.reservoir.level) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.p_condenser, BOP.reservoir.A, BOP.reservoir.V0, BOP.reservoir.level_start, BOP.reservoir.h_start, BOP.feedWaterHeater.medium.p, BOP.PID1.k, BOP.PID1.yb, BOP.PID1.yMax, BOP.PID1.yMin, BOP.PID1.wp, BOP.PID1.PID.addP.k2, BOP.PID1.PID.P.k, BOP.PID1.PID.addPID.k1, BOP.PID1.PID.addPID.k2, BOP.PID1.PID.addPID.k3, BOP.PID1.PID.Fzero.k, BOP.PID1.PID.addFF.k1, BOP.PID1.PID.addFF.k2, BOP.PID1.PID.addFF.k3, BOP.PID1.PID.I.y, BOP.PID1.PID.Dzero.k, source1.m_flow}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {BOP.PID1.pre_y_start}, fill(0,0), {16777294, 16777312, 16777313, 16777314, 16777315, 33554442, 16777392, 16777395, 16777396, 16777397, 16777398, 16777406, 16777407, 16777408, 16777409, 16777410, 16777411, 16777412, 16777413, 16777414, 33554449, 16777420, 16777423}, fill(0,0), fill(0,0), {16777404}, fill(0,0), {587202568});
    else
      der(BOP.reservoir.level) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.volume.medium.p, BOP.reservoir.level, BOP.reservoir.h, BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.volume_bypass.medium.p, BOP.PID1.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554438, 33554440, 33554441, 33554442, 33554443, 33554445, 33554449}, fill(0,0), fill(0,0), {587202568});
    end if;
    if initial() then
      der(BOP.reservoir.h) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.p_condenser, BOP.reservoir.A, BOP.reservoir.V0, BOP.reservoir.level_start, BOP.reservoir.h_start, BOP.feedWaterHeater.medium.p, BOP.PID1.k, BOP.PID1.yb, BOP.PID1.yMax, BOP.PID1.yMin, BOP.PID1.wp, BOP.PID1.PID.addP.k2, BOP.PID1.PID.P.k, BOP.PID1.PID.addPID.k1, BOP.PID1.PID.addPID.k2, BOP.PID1.PID.addPID.k3, BOP.PID1.PID.Fzero.k, BOP.PID1.PID.addFF.k1, BOP.PID1.PID.addFF.k2, BOP.PID1.PID.addFF.k3, BOP.PID1.PID.I.y, BOP.PID1.PID.Dzero.k, source1.m_flow}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {BOP.PID1.pre_y_start}, fill(0,0), {16777294, 16777312, 16777313, 16777314, 16777315, 33554442, 16777392, 16777395, 16777396, 16777397, 16777398, 16777406, 16777407, 16777408, 16777409, 16777410, 16777411, 16777412, 16777413, 16777414, 33554449, 16777420, 16777423}, fill(0,0), fill(0,0), {16777404}, fill(0,0), {587202569});
    else
      der(BOP.reservoir.h) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.volume.medium.p, BOP.reservoir.level, BOP.reservoir.h, BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.volume_bypass.medium.p, BOP.PID1.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554438, 33554440, 33554441, 33554442, 33554443, 33554445, 33554449}, fill(0,0), fill(0,0), {587202569});
    end if;
    if initial() then
      der(BOP.feedWaterHeater.medium.p) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.reservoir.level_start, BOP.reservoir.h_start, BOP.feedWaterHeater.medium.p, BOP.PID.k, BOP.PID.yb, BOP.PID.yMax, BOP.PID.wp, BOP.PID.addP.k2, BOP.PID.P.k, BOP.PID.addPID.k1, BOP.PID.addPID.k2, BOP.PID.addPID.k3, BOP.PID.Fzero.k, BOP.PID.addFF.k1, BOP.PID.addFF.k2, BOP.PID.addFF.k3, BOP.PID.I.y, BOP.PID.Dzero.k, massFlowToPressure.h0_causal, massFlowToPressure.h0_acausal, m_in_port_b, h_in_port_b}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314, 16777315, 33554442, 16777323, 16777326, 16777328, 16777329, 16777335, 16777336, 16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 33554444, 16777349, 16777426, 16777427, 352321539, 352321540}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202570});
    else
      der(BOP.feedWaterHeater.medium.p) = fmi_Functions.GetRealVariable(fmi, myTime, {m_in_port_b, h_in_port_b}, fill(0.0,0), {BOP.reservoir.level, BOP.reservoir.h, BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321539, 352321540}, fill(0,0), {33554440, 33554441, 33554442, 33554443, 33554444}, fill(0,0), fill(0,0), {587202570});
    end if;
    if initial() then
      der(BOP.feedWaterHeater.medium.h) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.reservoir.level_start, BOP.reservoir.h_start, BOP.feedWaterHeater.medium.p, BOP.PID.k, BOP.PID.yb, BOP.PID.yMax, BOP.PID.wp, BOP.PID.addP.k2, BOP.PID.P.k, BOP.PID.addPID.k1, BOP.PID.addPID.k2, BOP.PID.addPID.k3, BOP.PID.Fzero.k, BOP.PID.addFF.k1, BOP.PID.addFF.k2, BOP.PID.addFF.k3, BOP.PID.I.y, BOP.PID.Dzero.k, massFlowToPressure.h0_causal, massFlowToPressure.h0_acausal, m_in_port_b, h_in_port_b}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777314, 16777315, 33554442, 16777323, 16777326, 16777328, 16777329, 16777335, 16777336, 16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 33554444, 16777349, 16777426, 16777427, 352321539, 352321540}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202571});
    else
      der(BOP.feedWaterHeater.medium.h) = fmi_Functions.GetRealVariable(fmi, myTime, {m_in_port_b, h_in_port_b}, fill(0.0,0), {BOP.reservoir.level, BOP.reservoir.h, BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321539, 352321540}, fill(0,0), {33554440, 33554441, 33554442, 33554443, 33554444}, fill(0,0), fill(0,0), {587202571});
    end if;
    if initial() then
      der(BOP.PID.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.feedWaterHeater.medium.p, BOP.PID.k, BOP.PID.Ti, BOP.PID.yb, BOP.PID.yMax, BOP.PID.wp, BOP.PID.Ni, BOP.PID.addP.k2, BOP.PID.P.k, BOP.PID.addPID.k1, BOP.PID.addPID.k2, BOP.PID.addPID.k3, BOP.PID.Fzero.k, BOP.PID.addFF.k1, BOP.PID.addFF.k2, BOP.PID.addFF.k3, BOP.PID.I.y, BOP.PID.addI.k1, BOP.PID.addI.k2, BOP.PID.addI.k3, BOP.PID.addSat.k1, BOP.PID.addSat.k2, BOP.PID.Dzero.k, massFlowToPressure.h0_causal, massFlowToPressure.h0_acausal, m_in_port_b, h_in_port_b}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {33554442, 16777323, 16777324, 16777326, 16777328, 16777329, 16777331, 16777335, 16777336, 16777337, 16777338, 16777339, 16777340, 16777341, 16777342, 16777343, 33554444, 16777344, 16777345, 16777346, 16777347, 16777348, 16777349, 16777426, 16777427, 352321539, 352321540}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202572});
    else
      der(BOP.PID.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, {m_in_port_b, h_in_port_b}, fill(0.0,0), {BOP.feedWaterHeater.medium.p, BOP.feedWaterHeater.medium.h, BOP.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321539, 352321540}, fill(0,0), {33554442, 33554443, 33554444}, fill(0,0), fill(0,0), {587202572});
    end if;
    if initial() then
      der(BOP.volume_bypass.medium.p) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.I.y, BOP.CS.PID_BV_opening.Dzero.k, BOP.CS.BV_opening.k1, BOP.CS.BV_opening.k2, BOP.CS.BV_diffopeningNominal.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.generator1.eta, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.Fxt_full, BOP.valve_TCV.dp_nominal, sinkElec.f, BOP_Demand}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777223, 16777226, 16777227, 16777228, 16777260, 16777263, 16777264, 16777265, 16777267, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 33554433, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777294, 16777302, 16777359, 16777360, 16777363, 16777372, 16777422, 352321536}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {587202573});
    else
      der(BOP.volume_bypass.medium.p) = fmi_Functions.GetRealVariable(fmi, myTime, {BOP_Demand}, fill(0.0,0), {BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]', BOP.volume_bypass.medium.p, BOP.volume_bypass.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554433, 33554435, 33554436, 33554445, 33554446, 33554447, 33554448}, fill(0,0), fill(0,0), {587202573});
    end if;
    if initial() then
      der(BOP.volume_bypass.medium.h) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.I.y, BOP.CS.PID_BV_opening.Dzero.k, BOP.CS.BV_opening.k1, BOP.CS.BV_opening.k2, BOP.CS.BV_diffopeningNominal.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.generator1.eta, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.Fxt_full, BOP.valve_TCV.dp_nominal, sinkElec.f, BOP_Demand}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777223, 16777226, 16777227, 16777228, 16777260, 16777263, 16777264, 16777265, 16777267, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 33554433, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777294, 16777302, 16777359, 16777360, 16777363, 16777372, 16777422, 352321536}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {587202574});
    else
      der(BOP.volume_bypass.medium.h) = fmi_Functions.GetRealVariable(fmi, myTime, {BOP_Demand}, fill(0.0,0), {BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]', BOP.volume_bypass.medium.p, BOP.volume_bypass.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536}, fill(0,0), {33554433, 33554435, 33554436, 33554445, 33554446, 33554447, 33554448}, fill(0,0), fill(0,0), {587202574});
    end if;
    if initial() then
      der(BOP.header.medium.p) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.I.y, BOP.CS.PID_BV_opening.Dzero.k, BOP.CS.BV_opening.k1, BOP.CS.BV_opening.k2, BOP.CS.BV_diffopeningNominal.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.generator1.eta, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.Fxt_full, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full, sinkElec.f, BOP_Demand, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, h_in_port_a, p_in_port_a}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777260, 16777263, 16777264, 16777265, 16777267, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 33554433, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777294, 16777298, 16777300, 16777302, 16777359, 16777360, 16777363, 16777372, 16777373, 16777376, 16777422, 352321536, 16777428, 16777429, 352321537, 352321538}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {587202575});
    else
      der(BOP.header.medium.p) = fmi_Functions.GetRealVariable(fmi, myTime, {BOP_Demand, h_in_port_a, p_in_port_a}, fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]', BOP.volume.medium.p, BOP.volume.medium.h, BOP.volume_bypass.medium.p, BOP.volume_bypass.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321538}, fill(0,0), {33554432, 33554433, 33554435, 33554436, 33554438, 33554439, 33554445, 33554446, 33554447, 33554448}, fill(0,0), fill(0,0), {587202575});
    end if;
    if initial() then
      der(BOP.header.medium.h) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.CS.delayStartTCV, BOP.CS.p_nominal, BOP.CS.TCV_opening_nominal, BOP.CS.BV_opening_nominal, BOP.CS.clock.offset, BOP.CS.clock.startTime, BOP.CS.PID_TCV_opening.k, BOP.CS.PID_TCV_opening.yb, BOP.CS.PID_TCV_opening.k_s, BOP.CS.PID_TCV_opening.k_m, BOP.CS.PID_TCV_opening.wp, BOP.CS.PID_TCV_opening.addP.k2, BOP.CS.PID_TCV_opening.P.k, BOP.CS.PID_TCV_opening.addPID.k1, BOP.CS.PID_TCV_opening.addPID.k2, BOP.CS.PID_TCV_opening.addPID.k3, BOP.CS.PID_TCV_opening.Fzero.k, BOP.CS.PID_TCV_opening.addFF.k1, BOP.CS.PID_TCV_opening.addFF.k2, BOP.CS.PID_TCV_opening.addFF.k3, BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_TCV_opening.Dzero.k, BOP.CS.TCV_diffopeningNominal.k, BOP.CS.TCV_opening.k1, BOP.CS.TCV_opening.k2, BOP.CS.PID_BV_opening.k, BOP.CS.PID_BV_opening.yb, BOP.CS.PID_BV_opening.k_s, BOP.CS.PID_BV_opening.k_m, BOP.CS.PID_BV_opening.wp, BOP.CS.PID_BV_opening.addP.k2, BOP.CS.PID_BV_opening.P.k, BOP.CS.PID_BV_opening.addPID.k1, BOP.CS.PID_BV_opening.addPID.k2, BOP.CS.PID_BV_opening.addPID.k3, BOP.CS.PID_BV_opening.Fzero.k, BOP.CS.PID_BV_opening.addFF.k1, BOP.CS.PID_BV_opening.addFF.k2, BOP.CS.PID_BV_opening.addFF.k3, BOP.CS.PID_BV_opening.I.y, BOP.CS.PID_BV_opening.Dzero.k, BOP.CS.BV_opening.k1, BOP.CS.BV_opening.k2, BOP.CS.BV_diffopeningNominal.k, BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.steamTurbine.eta_wetSteam.eta_nominal, BOP.steamTurbine.partialArc_nominal, BOP.generator1.eta, BOP.valve_BV.dp_nominal, BOP.valve_BV.opening_nominal, BOP.valve_BV.Fxt_full, BOP.valve_TCV.dp_nominal, BOP.valve_TCV.opening_nominal, BOP.valve_TCV.Fxt_full, sinkElec.f, BOP_Demand, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, h_in_port_a, p_in_port_a}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777223, 16777224, 16777225, 16777226, 16777227, 16777228, 16777229, 16777232, 16777233, 16777234, 16777236, 16777242, 16777243, 16777244, 16777245, 16777246, 16777247, 16777248, 16777249, 16777250, 33554432, 16777256, 16777257, 16777258, 16777259, 16777260, 16777263, 16777264, 16777265, 16777267, 16777273, 16777274, 16777275, 16777276, 16777277, 16777278, 16777279, 16777280, 16777281, 33554433, 16777287, 16777288, 16777289, 16777290, 16777291, 16777292, 16777294, 16777298, 16777300, 16777302, 16777359, 16777360, 16777363, 16777372, 16777373, 16777376, 16777422, 352321536, 16777428, 16777429, 352321537, 352321538}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {587202576});
    else
      der(BOP.header.medium.h) = fmi_Functions.GetRealVariable(fmi, myTime, {BOP_Demand, h_in_port_a, p_in_port_a}, fill(0.0,0), {BOP.CS.PID_TCV_opening.I.y, BOP.CS.PID_BV_opening.I.y, BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]', BOP.volume.medium.p, BOP.volume.medium.h, BOP.volume_bypass.medium.p, BOP.volume_bypass.medium.h, BOP.header.medium.p, BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321538}, fill(0,0), {33554432, 33554433, 33554435, 33554436, 33554438, 33554439, 33554445, 33554446, 33554447, 33554448}, fill(0,0), fill(0,0), {587202576});
    end if;
    if initial() then
      der(BOP.PID1.PID.I.y) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.reservoir.level_start, BOP.PID1.k, BOP.PID1.Ti, BOP.PID1.yb, BOP.PID1.yMax, BOP.PID1.yMin, BOP.PID1.wp, BOP.PID1.Ni, BOP.PID1.PID.addP.k2, BOP.PID1.PID.P.k, BOP.PID1.PID.addPID.k1, BOP.PID1.PID.addPID.k2, BOP.PID1.PID.addPID.k3, BOP.PID1.PID.Fzero.k, BOP.PID1.PID.addFF.k1, BOP.PID1.PID.addFF.k2, BOP.PID1.PID.addFF.k3, BOP.PID1.PID.I.y, BOP.PID1.PID.addI.k1, BOP.PID1.PID.addI.k2, BOP.PID1.PID.addI.k3, BOP.PID1.PID.addSat.k1, BOP.PID1.PID.addSat.k2, BOP.PID1.PID.Dzero.k}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, {BOP.PID1.pre_y_start}, fill(0,0), {16777314, 16777392, 16777393, 16777395, 16777396, 16777397, 16777398, 16777400, 16777406, 16777407, 16777408, 16777409, 16777410, 16777411, 16777412, 16777413, 16777414, 33554449, 16777415, 16777416, 16777417, 16777418, 16777419, 16777420}, fill(0,0), fill(0,0), {16777404}, fill(0,0), {587202577});
    else
      der(BOP.PID1.PID.I.y) = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.reservoir.level, BOP.PID1.PID.I.y}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554440, 33554449}, fill(0,0), fill(0,0), {587202577});
    end if;
    if initial() then
      Power = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, BOP.port_a_nominal.m_flow, BOP.p_condenser, BOP.generator1.eta, BOP.valve_TCV.dp_nominal, sinkElec.f}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), {BOP.generator1.nPoles}, {16777291, 16777292, 16777294, 16777302, 16777372, 16777422}, fill(0,0), fill(0,0), fill(0,0), {16777303}, {335544320});
    else
      Power = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.steamTurbine.'Q_units[1]', BOP.steamTurbine.'Q_units[2]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554435, 33554436}, fill(0,0), fill(0,0), {335544320});
    end if;
    if initial() then
      freq = fmi_Functions.GetRealVariable(fmi, myTimeStart, {sinkElec.f}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777422}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {67108865});
    else
      freq = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {67108865});
    end if;
    if initial() then
      m_flow_out_port_a = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, p_in_port_a}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 352321538}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544322});
    else
      m_flow_out_port_a = fmi_Functions.GetRealVariable(fmi, myTime, {p_in_port_a}, fill(0.0,0), {BOP.header.medium.p}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321538}, fill(0,0), {33554447}, fill(0,0), fill(0,0), {335544322});
    end if;
    if initial() then
      h_out_port_a = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.port_a_nominal.p, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777291, 16777428, 16777429}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544323});
    else
      h_out_port_a = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.header.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554448}, fill(0,0), fill(0,0), {335544323});
    end if;
    if initial() then
      p_out_port_b = fmi_Functions.GetRealVariable(fmi, myTimeStart, {BOP.feedWaterHeater.medium.p, m_in_port_b}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {33554442, 352321539}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544324});
    else
      p_out_port_b = fmi_Functions.GetRealVariable(fmi, myTime, {m_in_port_b}, fill(0.0,0), {BOP.feedWaterHeater.medium.p}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321539}, fill(0,0), {33554442}, fill(0,0), fill(0,0), {335544324});
    end if;
    if initial() then
      h_out_port_b = fmi_Functions.GetRealVariable(fmi, myTimeStart, {massFlowToPressure.h0_causal, massFlowToPressure.h0_acausal}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777426, 16777427}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544325});
    else
      h_out_port_b = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {BOP.feedWaterHeater.medium.h}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554443}, fill(0,0), fill(0,0), {335544325});
    end if;
  {BOP.CS.W_totalSetpoint, BOP.CS.actuatorBus.opening_TCV, BOP.CS.actuatorBus.opening_BV, BOP.CS.sensorBus.W_total, BOP.CS.switch_BV.u1, BOP.CS.switch_BV.y, BOP.CS.greater5.u1, BOP.CS.PID_TCV_opening.u_s, BOP.CS.PID_TCV_opening.y, BOP.CS.PID_TCV_opening.controlError, BOP.CS.PID_TCV_opening.addP.u1, BOP.CS.PID_TCV_opening.addP.y, BOP.CS.PID_TCV_opening.P.y, BOP.CS.PID_TCV_opening.gainPID.u, BOP.CS.PID_TCV_opening.gainPID.y, BOP.CS.PID_TCV_opening.limiter.u, BOP.CS.PID_TCV_opening.I.u, BOP.CS.PID_TCV_opening.addI.u3, BOP.CS.PID_TCV_opening.addSat.y, BOP.CS.switch_TCV_setpoint.y, BOP.CS.switch_P_setpoint.y, BOP.CS.PID_BV_opening.controlError, BOP.CS.PID_BV_opening.addP.u1, BOP.CS.PID_BV_opening.addP.u2, BOP.CS.PID_BV_opening.addP.y, BOP.CS.PID_BV_opening.P.y, BOP.CS.PID_BV_opening.gainPID.u, BOP.CS.PID_BV_opening.gainPID.y, BOP.CS.PID_BV_opening.limiter.u, BOP.CS.PID_BV_opening.I.u, BOP.CS.PID_BV_opening.addI.u3, BOP.CS.PID_BV_opening.addSat.y, BOP.port_a.m_flow, BOP.port_a.p, BOP.port_b.m_flow, BOP.port_b.p, BOP.port_b.h_outflow, BOP.steamTurbine.p_ratio, BOP.steamTurbine.tau, BOP.steamTurbine.omega, BOP.steamTurbine.m_flow, BOP.steamTurbine.h_out, BOP.steamTurbine.h_is, BOP.steamTurbine.p_in, BOP.steamTurbine.Q_mech, BOP.steamTurbine.'Qbs[1]', BOP.steamTurbine.'Qbs[2]', BOP.steamTurbine.h_fsat_in, BOP.steamTurbine.h_gsat_in, BOP.steamTurbine.h_fsat_out, BOP.steamTurbine.h_gsat_out, BOP.steamTurbine.x_th_in, BOP.steamTurbine.x_abs_in, BOP.steamTurbine.x_th_out, BOP.steamTurbine.x_abs_out, BOP.steamTurbine.portHP.h_outflow, BOP.steamTurbine.portLP.m_flow, BOP.steamTurbine.portLP.h_outflow, BOP.steamTurbine.state_a.d, BOP.steamTurbine.state_a.T, BOP.steamTurbine.state_b.d, BOP.steamTurbine.state_b.T, BOP.steamTurbine.sat_in.psat, BOP.steamTurbine.sat_in.Tsat, BOP.steamTurbine.sat_out.psat, BOP.steamTurbine.sat_out.Tsat, BOP.steamTurbine.bubble_in.d, BOP.steamTurbine.dew_in.d, BOP.steamTurbine.bubble_out.d, BOP.steamTurbine.dew_out.d, BOP.generator1.Q_mech, BOP.generator1.tau, BOP.generator1.shaft_rpm, BOP.sensorW.y, BOP.resistance.dp, BOP.resistance.m_flow, BOP.resistance.port_b.m_flow, BOP.resistance.state.d, BOP.resistance.state.T, BOP.condenser.m_total, BOP.condenser.m_liquid, BOP.condenser._m_liquid_der, BOP.condenser.m_vapor, BOP.condenser._m_vapor_der, BOP.condenser.V_vapor, BOP.condenser.E, BOP.condenser._E_der, BOP.condenser.Q_total, BOP.condenser.port_a.m_flow, BOP.condenser.port_b.m_flow, BOP.volume.m, BOP.volume._m_der, BOP.volume.U, BOP.volume._U_der, BOP.volume.medium.d, BOP.volume.medium._d_der, BOP.volume.medium.T, BOP.volume.medium.u, BOP.volume.medium._u_der, BOP.volume.medium.T_degC} = fmi_Functions.fmiGetRealwf(fmi, {436207616, 637534324, 637534325, 369098764, 637534223, 637534225, 637534227, 637534230, 637534231, 905969688, 637534243, 637534245, 637534247, 637534249, 637534250, 637534256, 637534264, 637534272, 637534273, 637534275, 637534276, 905969734, 637534289, 637534290, 637534291, 637534293, 637534295, 637534296, 637534302, 637534310, 637534318, 637534319, 369099301, 905969809, 436207619, 369098898, 369098899, 637534384, 369098906, 318767106, 637534357, 637534385, 637534386, 637534358, 637534387, 637534388, 637534389, 905969852, 905969855, 905969858, 905969861, 905969863, 905969864, 905969865, 905969866, 637534359, 637534759, 637534360, 637534379, 905969836, 905969838, 905969839, 905969847, 905969848, 905969849, 905969850, 905969853, 905969856, 905969859, 905969862, 369098967, 369098972, 905969883, 369098973, 905969892, 637534430, 637534432, 905969890, 905969891, 905969905, 905969907, 637534452, 905969909, 905969910, 905969911, 905969912, 905969913, 905969914, 637534438, 637534439, 637534482, 637534483, 905969940, 637534485, 637534468, 637534469, 905969926, 637534472, 637534473, 905969935}, if initial() then myTimeStart else myTime);
  {BOP.volume.medium.p_bar, BOP.volume.medium.sat.Tsat, BOP.reservoir.V, BOP.reservoir._V_der, BOP.reservoir.m, BOP.reservoir._m_der, BOP.reservoir.U, BOP.reservoir._U_der, BOP.reservoir.p, BOP.reservoir.d, BOP.reservoir.T, BOP.reservoir.port_a.m_flow, BOP.reservoir.port_b.m_flow, BOP.reservoir.port_b.p, BOP.reservoir.state._d_der, BOP.multiPort.port_a.m_flow, BOP.multiPort.port_a.h_outflow, BOP.multiPort.'ports_b[2]'.m_flow, BOP.feedWaterHeater.m, BOP.feedWaterHeater._m_der, BOP.feedWaterHeater.U, BOP.feedWaterHeater._U_der, BOP.feedWaterHeater.port_a.m_flow, BOP.feedWaterHeater.medium.d, BOP.feedWaterHeater.medium._d_der, BOP.feedWaterHeater.medium.T, BOP.feedWaterHeater.medium.u, BOP.feedWaterHeater.medium._u_der, BOP.feedWaterHeater.medium.T_degC, BOP.feedWaterHeater.medium.p_bar, BOP.feedWaterHeater.medium.sat.Tsat, BOP.feedWaterHeater.heatPort.Q_flow, BOP.boundary.port.Q_flow, BOP.PID.u_s, BOP.PID.u_m, BOP.PID.controlError, BOP.PID.addP.u2, BOP.PID.addP.y, BOP.PID.P.y, BOP.PID.gainPID.u, BOP.PID.gainPID.y, BOP.PID.limiter.u, BOP.PID.I.u, BOP.PID.addI.u3, BOP.PID.addSat.y, BOP.temperature.y, BOP.temperature.T, BOP.multiPort1.port_a.h_outflow, BOP.multiPort1.port_a._h_outflow_der, BOP.multiPort1.'ports_b[1]'.m_flow, BOP.resistance1.dp, BOP.resistance1.m_flow, BOP.resistance1.port_a.h_outflow, BOP.resistance1.state.d, BOP.resistance1.state.T, BOP.valve_BV.m_flow, BOP.valve_BV.dp, BOP.valve_BV.V_flow, BOP.valve_BV.port_a_T, BOP.valve_BV.port_b_T, BOP.valve_BV.x, BOP.valve_BV.xs, BOP.valve_BV.Y, BOP.valve_BV.p, BOP.valve_BV.port_b.m_flow, BOP.volume_bypass.m, BOP.volume_bypass._m_der, BOP.volume_bypass.U, BOP.volume_bypass._U_der, BOP.volume_bypass.port_b.m_flow, BOP.volume_bypass.medium.d, BOP.volume_bypass.medium._d_der, BOP.volume_bypass.medium.T, BOP.volume_bypass.medium.u, BOP.volume_bypass.medium._u_der, BOP.volume_bypass.medium.T_degC, BOP.volume_bypass.medium.p_bar, BOP.volume_bypass.medium.sat.Tsat, BOP.resistance3.dp, BOP.resistance3.state.d, BOP.resistance3.state.T, BOP.valve_TCV.dp, BOP.valve_TCV.V_flow, BOP.valve_TCV.port_a_T, BOP.valve_TCV.port_b_T, BOP.valve_TCV.x, BOP.valve_TCV.xs, BOP.valve_TCV.Y, BOP.valve_TCV.p, BOP.header.m, BOP.header._m_der, BOP.header.U, BOP.header._U_der, BOP.header.'H_flows_a[1]', BOP.header.'H_flows_b[1]', BOP.header.'H_flows_b[2]', BOP.header.medium.d, BOP.header.medium.T, BOP.header.medium.u, BOP.header.medium._u_der} = fmi_Functions.fmiGetRealwf(fmi, {905969936, 905969937, 637534508, 637534509, 637534510, 637534511, 905969968, 637534513, 905969970, 637534516, 905969974, 637534496, 637534498, 637534499, 637534517, 637534525, 637534527, 637534948, 637534553, 637534554, 905970011, 637534556, 637534530, 637534540, 637534541, 905970025, 637534543, 637534544, 905970006, 905970007, 905970008, 637534566, 637534568, 100663686, 637534570, 905970027, 637534584, 637534585, 637534587, 637534589, 637534590, 637534596, 637534605, 637534613, 637534614, 905970075, 637534620, 905970078, 905970079, 637534624, 905970084, 905970085, 637535005, 905970082, 905970083, 637534635, 637534641, 905970098, 905970099, 905970100, 637534663, 637534664, 637534665, 637534666, 637534758, 637534696, 637534697, 905970154, 637534699, 637534710, 637534682, 637534683, 905970140, 637534686, 637534687, 905970149, 905970150, 905970151, 905970170, 905970168, 905970169, 637534723, 905970180, 905970181, 905970182, 637534745, 637534746, 637534747, 637534748, 637534783, 637534784, 905970241, 637534786, 637534793, 637534794, 637534795, 637534770, 905970227, 637534773, 637534774}, if initial() then myTimeStart else myTime);
  {BOP.header.medium.T_degC, BOP.header.medium.p_bar, BOP.header.medium.sat.Tsat, BOP.resistance4.dp, BOP.resistance4.port_b.h_outflow, BOP.resistance4.state.d, BOP.resistance4.state.T, BOP.'checkValve[1]'.port_b.m_flow, BOP.'massFlowRate[1]'.y, BOP.'specificEnthalpy[1]'.y, BOP.powerSensor.power, BOP.resistance2.dp, BOP.resistance2.state.d, BOP.resistance2.state.T, BOP.PID1.PID.u_s, BOP.PID1.PID.y, BOP.PID1.PID.controlError, BOP.PID1.PID.addP.u1, BOP.PID1.PID.addP.u2, BOP.PID1.PID.addP.y, BOP.PID1.PID.P.y, BOP.PID1.PID.gainPID.u, BOP.PID1.PID.gainPID.y, BOP.PID1.PID.limiter.u, BOP.PID1.PID.I.u, BOP.PID1.PID.addI.u3, BOP.PID1.PID.addSat.y, BOP.PID1.hys.u, BOP.boundary2.'ports[1]'.m_flow, massFlowToPressure.h_in, pressureToMassFlow.p_in, pressureToMassFlow.h_in} = fmi_Functions.fmiGetRealwf(fmi, {905970236, 905970237, 905970238, 905970260, 637535014, 905970258, 905970259, 905970290, 905970323, 100663957, 905970326, 905970330, 905970328, 905970329, 637534885, 637534886, 905970343, 637534910, 637534911, 637534912, 637534914, 637534916, 637534917, 637534923, 637534931, 637534939, 637534940, 637534945, 637534967, 436207620, 436207618, 436207617}, if initial() then myTimeStart else myTime);
  //alias Declarations
    BOP.CS.TCV_openingNominal.y = BOP.CS.TCV_openingNominal.k;
    BOP.CS.TCV_opening.u2 = BOP.CS.TCV_openingNominal.k;
    BOP.CS.BV_openingNominal.y = BOP.CS.BV_openingNominal.k;
    BOP.CS.BV_opening.u2 = BOP.CS.BV_openingNominal.k;
    BOP.CS.valvedelay.k = BOP.CS.greater5.u2;
    BOP.CS.valvedelay.y = BOP.CS.greater5.u2;
    BOP.CS.PID_TCV_opening.gain_u_m.y = BOP.CS.PID_TCV_opening.addP.u2;
    BOP.CS.PID_TCV_opening.addI.u2 = BOP.CS.PID_TCV_opening.addP.u2;
    BOP.CS.PID_TCV_opening.null_bias.k = BOP.CS.PID_TCV_opening.addFF.u3;
    BOP.CS.PID_TCV_opening.null_bias.y = BOP.CS.PID_TCV_opening.addFF.u3;
    BOP.CS.valvedelayBV.y = BOP.CS.valvedelayBV.k;
    BOP.CS.greater1.u2 = BOP.CS.valvedelayBV.k;
    BOP.CS.PID_BV_opening.null_bias.k = BOP.CS.PID_BV_opening.addFF.u3;
    BOP.CS.PID_BV_opening.null_bias.y = BOP.CS.PID_BV_opening.addFF.u3;
    BOP.CS.PID_TCV_opening.gain_u_m.u = BOP.CS.PID_TCV_opening.u_m;
    BOP.CS.switch_P_setpoint_TCV.u3 = BOP.CS.PID_TCV_opening.u_m;
    BOP.CS.p_Nominal1.k = BOP.CS.PID_TCV_opening.u_m;
    BOP.CS.p_Nominal1.y = BOP.CS.PID_TCV_opening.u_m;
    BOP.condenser.h_gsat = BOP.resistance.port_a.h_outflow;
    BOP.condenser.port_a.h_outflow = BOP.resistance.port_a.h_outflow;
    BOP.multiPort1.'ports_b[1]'.h_outflow = BOP.resistance.port_a.h_outflow;
    BOP.multiPort1.'ports_b[2]'.h_outflow = BOP.resistance.port_a.h_outflow;
    BOP.multiPort1.'ports_b[3]'.h_outflow = BOP.resistance.port_a.h_outflow;
    BOP.resistance3.port_a.h_outflow = BOP.resistance.port_a.h_outflow;
    BOP.condenser.port_b.h_outflow = BOP.condenser.h_fsat;
    BOP.condenser.p = BOP.resistance.port_b.p;
    BOP.condenser.port_a.p = BOP.resistance.port_b.p;
    BOP.condenser.sat.psat = BOP.resistance.port_b.p;
    BOP.multiPort1.port_a.p = BOP.resistance.port_b.p;
    BOP.multiPort1.'ports_b[1]'.p = BOP.resistance.port_b.p;
    BOP.multiPort1.'ports_b[2]'.p = BOP.resistance.port_b.p;
    BOP.multiPort1.'ports_b[3]'.p = BOP.resistance.port_b.p;
    BOP.resistance3.port_b.p = BOP.resistance.port_b.p;
    BOP.'boundary_m_flow_a3[1]'.medium.p = BOP.resistance.port_b.p;
    BOP.'boundary_m_flow_a3[1]'.medium.state.p = BOP.resistance.port_b.p;
    BOP.'boundary_m_flow_a3[1]'.medium.sat.psat = BOP.resistance.port_b.p;
    BOP.PID.gain_u_s.y = BOP.PID.addP.u1;
    BOP.PID.addI.u1 = BOP.PID.addP.u1;
    BOP.PID.gain_u_s.u = BOP.PID.u_s;
    BOP.realExpression.y = BOP.PID.u_s;
    BOP.PID.null_bias.k = BOP.PID.addFF.u3;
    BOP.PID.null_bias.y = BOP.PID.addFF.u3;
    BOP.valve_BV.dp_turbulent = BOP.valve_BV.dp_small;
    BOP.valve_TCV.dp_turbulent = BOP.valve_TCV.dp_small;
    BOP.'boundary_a3[1]'.medium.state.d = BOP.'boundary_a3[1]'.medium.d;
    BOP.'boundary_a3[1]'.medium.state.T = BOP.'boundary_a3[1]'.medium.T;
    BOP.'boundary_a3[1]'.h = BOP.'port_a3[1]'.h_outflow;
    BOP.'boundary_a3[1]'.medium.h = BOP.'port_a3[1]'.h_outflow;
    BOP.'boundary_a3[1]'.medium.state.h = BOP.'port_a3[1]'.h_outflow;
    BOP.'boundary_a3[1]'.'ports[1]'.h_outflow = BOP.'port_a3[1]'.h_outflow;
    BOP.'checkValve[1]'.port_a.h_outflow = BOP.'port_a3[1]'.h_outflow;
    BOP.'massFlowRate[1]'.port_a.h_outflow = BOP.'port_a3[1]'.h_outflow;
    BOP.'specificEnthalpy[1]'.port_a.h_outflow = BOP.'port_a3[1]'.h_outflow;
    BOP.'boundary_m_flow_a3[1]'.medium.state.d = BOP.'boundary_m_flow_a3[1]'.medium.d;
    BOP.'boundary_m_flow_a3[1]'.medium.state.T = BOP.'boundary_m_flow_a3[1]'.medium.T;
    BOP.'boundary_m_flow_a3[1]'.medium.h = BOP.'boundary_m_flow_a3[1]'.h_in;
    BOP.'boundary_m_flow_a3[1]'.medium.state.h = BOP.'boundary_m_flow_a3[1]'.h_in;
    BOP.'boundary_m_flow_a3[1]'.'ports[1]'.h_outflow = BOP.'boundary_m_flow_a3[1]'.h_in;
    BOP.'specificEnthalpy[1]'.var = BOP.'boundary_m_flow_a3[1]'.h_in;
    BOP.'specificEnthalpy[1]'.h_out = BOP.'boundary_m_flow_a3[1]'.h_in;
    BOP.PID1.PID.null_bias.k = BOP.PID1.PID.addFF.u3;
    BOP.PID1.PID.null_bias.y = BOP.PID1.PID.addFF.u3;
    BOP.boundary2.medium.state.d = BOP.boundary2.medium.d;
    BOP.boundary2.medium.state.T = BOP.boundary2.medium.T;
    BOP.boundary2.medium.state.h = BOP.boundary2.medium.h;
    BOP.boundary2.'ports[1]'.h_outflow = BOP.boundary2.medium.h;
    source1.medium.state.d = source1.medium.d;
    source1.medium.state.T = source1.medium.T;
    BOP.'checkValve[1]'.port_a.p = BOP.'port_a3[1]'.p;
    BOP.'massFlowRate[1]'.port_a.p = BOP.'port_a3[1]'.p;
    BOP.'massFlowRate[1]'.port_b.p = BOP.'port_a3[1]'.p;
    BOP.'specificEnthalpy[1]'.port_a.p = BOP.'port_a3[1]'.p;
    BOP.'specificEnthalpy[1]'.port_b.p = BOP.'port_a3[1]'.p;
    source1.medium.p = BOP.'port_a3[1]'.p;
    source1.medium.state.p = BOP.'port_a3[1]'.p;
    source1.medium.sat.psat = BOP.'port_a3[1]'.p;
    source1.'ports[1]'.p = BOP.'port_a3[1]'.p;
    BOP.CS.PID_TCV_opening.addFF.u1 = BOP.CS.PID_TCV_opening.Fzero.y;
    BOP.CS.PID_TCV_opening.Dzero.y = BOP.CS.PID_TCV_opening.addPID.u2;
    BOP.CS.TCV_diffopeningNominal.y = BOP.CS.switch_TCV_setpoint.u3;
    BOP.CS.PID_BV_opening.addFF.u1 = BOP.CS.PID_BV_opening.Fzero.y;
    BOP.CS.PID_BV_opening.Dzero.y = BOP.CS.PID_BV_opening.addPID.u2;
    BOP.CS.BV_diffopeningNominal.y = BOP.CS.switch_BV.u3;
    BOP.steamTurbine.eta_wetSteam.eta = BOP.steamTurbine.eta_is;
    BOP.PID1.feeBac.u1 = BOP.PID1.u_s;
    BOP.level_setpoint.y = BOP.PID1.u_s;
    BOP.PID.addFF.u1 = BOP.PID.Fzero.y;
    BOP.PID.Dzero.y = BOP.PID.addPID.u2;
    BOP.PID1.PID.addFF.u1 = BOP.PID1.PID.Fzero.y;
    BOP.PID1.PID.Dzero.y = BOP.PID1.PID.addPID.u2;
    BOP.generator1.f = BOP.portElec_b.f;
    BOP.generator1.portElec.f = BOP.portElec_b.f;
    BOP.sensorW.port_a.f = BOP.portElec_b.f;
    BOP.sensorW.port_b.f = BOP.portElec_b.f;
    sinkElec.port.f = BOP.portElec_b.f;
    realExpression3.y = BOP.portElec_b.f;
    BOP.multiPort1.'ports_b[3]'.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'boundary_a3[1]'.'ports[1]'.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'checkValve[1]'.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'checkValve[1]'.port_a.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'boundary_m_flow_a3[1]'.m_flow_in = BOP.'port_a3[1]'.m_flow;
    BOP.'massFlowRate[1]'.var = BOP.'port_a3[1]'.m_flow;
    BOP.'massFlowRate[1]'.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'massFlowRate[1]'.port_a.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'specificEnthalpy[1]'.port_a.m_flow = BOP.'port_a3[1]'.m_flow;
    BOP.'massFlowRate[1]'.port_b.h_outflow = BOP.'checkValve[1]'.port_b.h_outflow;
    BOP.'specificEnthalpy[1]'.port_b.h_outflow = BOP.'checkValve[1]'.port_b.h_outflow;
    source1.medium.h = BOP.'checkValve[1]'.port_b.h_outflow;
    source1.medium.state.h = BOP.'checkValve[1]'.port_b.h_outflow;
    BOP.generator1.omega_m = BOP.steamTurbine.omega;
    BOP.generator1.shaft_a._phi_der = BOP.steamTurbine.omega;
    BOP.powerSensor.flange_a._phi_der = BOP.steamTurbine.omega;
    BOP.CS.PID_TCV_opening.addPID.u3 = BOP.CS.PID_TCV_opening.I.y;
    BOP.portElec_b.W = Power;
    BOP.generator1.portElec.W = Power;
    BOP.sensorW.port_b.W = Power;
    realExpression2.y = Power;
    BOP.resistance4.port_b.m_flow = m_flow_out_port_a;
    pressureToMassFlow.m_flow_out = m_flow_out_port_a;
    pressureToMassFlow.fluidPort.m_flow = m_flow_out_port_a;
    pressureToMassFlow.h_out = h_out_port_a;
    massFlowToPressure.p_out = p_out_port_b;
    massFlowToPressure.h_out = h_out_port_b;
    BOP.CS.PID_BV_opening.addPID.u3 = BOP.CS.PID_BV_opening.I.y;
    BOP.steamTurbine.shaft_a.phi = BOP.steamTurbine.phi;
    BOP.steamTurbine.shaft_b.phi = BOP.steamTurbine.phi;
    BOP.generator1.shaft_a.phi = BOP.steamTurbine.phi;
    BOP.powerSensor.flange_a.phi = BOP.steamTurbine.phi;
    BOP.powerSensor.flange_b.phi = BOP.steamTurbine.phi;
    BOP.steamTurbine.p_out = BOP.volume.medium.p;
    BOP.steamTurbine.portLP.p = BOP.volume.medium.p;
    BOP.steamTurbine.state_b.p = BOP.volume.medium.p;
    BOP.resistance.port_a.p = BOP.volume.medium.p;
    BOP.resistance.state.p = BOP.volume.medium.p;
    BOP.volume.port_a.p = BOP.volume.medium.p;
    BOP.volume.port_b.p = BOP.volume.medium.p;
    BOP.volume.medium.state.p = BOP.volume.medium.p;
    BOP.volume.medium.sat.psat = BOP.volume.medium.p;
    BOP.steamTurbine.state_b.h = BOP.volume.medium.h;
    BOP.resistance.port_b.h_outflow = BOP.volume.medium.h;
    BOP.resistance.state.h = BOP.volume.medium.h;
    BOP.volume.port_a.h_outflow = BOP.volume.medium.h;
    BOP.volume.port_b.h_outflow = BOP.volume.medium.h;
    BOP.volume.medium.state.h = BOP.volume.medium.h;
    BOP.PID1.u_m = BOP.reservoir.level;
    BOP.PID1.PID.u_m = BOP.reservoir.level;
    BOP.PID1.PID.gain_u_m.u = BOP.reservoir.level;
    BOP.PID1.feeBac.u2 = BOP.reservoir.level;
    BOP.level_measure.y = BOP.reservoir.level;
    BOP.reservoir.port_a.h_outflow = BOP.reservoir.h;
    BOP.reservoir.port_b.h_outflow = BOP.reservoir.h;
    BOP.reservoir.state.h = BOP.reservoir.h;
    BOP.multiPort.'ports_b[1]'.h_outflow = BOP.reservoir.h;
    BOP.multiPort.'ports_b[2]'.h_outflow = BOP.reservoir.h;
    BOP.resistance2.port_b.h_outflow = BOP.reservoir.h;
    BOP.resistance2.state.h = BOP.reservoir.h;
    BOP.feedWaterHeater.port_a.p = BOP.feedWaterHeater.medium.p;
    BOP.feedWaterHeater.port_b.p = BOP.feedWaterHeater.medium.p;
    BOP.feedWaterHeater.medium.state.p = BOP.feedWaterHeater.medium.p;
    BOP.feedWaterHeater.medium.sat.psat = BOP.feedWaterHeater.medium.p;
    BOP.temperature.port.p = BOP.feedWaterHeater.medium.p;
    BOP.resistance1.port_a.p = BOP.feedWaterHeater.medium.p;
    BOP.resistance1.state.p = BOP.feedWaterHeater.medium.p;
    BOP.resistance2.port_b.p = BOP.feedWaterHeater.medium.p;
    BOP.feedWaterHeater.port_a.h_outflow = BOP.feedWaterHeater.medium.h;
    BOP.feedWaterHeater.port_b.h_outflow = BOP.feedWaterHeater.medium.h;
    BOP.feedWaterHeater.medium.state.h = BOP.feedWaterHeater.medium.h;
    BOP.resistance2.port_a.h_outflow = BOP.feedWaterHeater.medium.h;
    BOP.PID.addPID.u3 = BOP.PID.I.y;
    BOP.valve_BV.port_b.p = BOP.volume_bypass.medium.p;
    BOP.volume_bypass.port_a.p = BOP.volume_bypass.medium.p;
    BOP.volume_bypass.port_b.p = BOP.volume_bypass.medium.p;
    BOP.volume_bypass.medium.state.p = BOP.volume_bypass.medium.p;
    BOP.volume_bypass.medium.sat.psat = BOP.volume_bypass.medium.p;
    BOP.resistance3.port_a.p = BOP.volume_bypass.medium.p;
    BOP.resistance3.state.p = BOP.volume_bypass.medium.p;
    BOP.valve_BV.port_a.h_outflow = BOP.volume_bypass.medium.h;
    BOP.volume_bypass.port_a.h_outflow = BOP.volume_bypass.medium.h;
    BOP.volume_bypass.port_b.h_outflow = BOP.volume_bypass.medium.h;
    BOP.volume_bypass.medium.state.h = BOP.volume_bypass.medium.h;
    BOP.resistance3.port_b.h_outflow = BOP.volume_bypass.medium.h;
    BOP.resistance3.state.h = BOP.volume_bypass.medium.h;
    BOP.CS.sensorBus.p_inlet_steamTurbine = BOP.header.medium.p;
    BOP.ED.sensorBus.p_inlet_steamTurbine = BOP.header.medium.p;
    BOP.sensorBus.p_inlet_steamTurbine = BOP.header.medium.p;
    BOP.pressure.p = BOP.header.medium.p;
    BOP.pressure.port.p = BOP.header.medium.p;
    BOP.valve_BV.port_a.p = BOP.header.medium.p;
    BOP.valve_TCV.port_a.p = BOP.header.medium.p;
    BOP.header.'port_a[1]'.p = BOP.header.medium.p;
    BOP.header.'port_b[1]'.p = BOP.header.medium.p;
    BOP.header.'port_b[2]'.p = BOP.header.medium.p;
    BOP.header.'port_b[3]'.p = BOP.header.medium.p;
    BOP.header.medium.state.p = BOP.header.medium.p;
    BOP.header.medium.sat.psat = BOP.header.medium.p;
    BOP.resistance4.port_b.p = BOP.header.medium.p;
    BOP.port_a.h_outflow = BOP.header.medium.h;
    BOP.steamTurbine.h_in = BOP.header.medium.h;
    BOP.steamTurbine.state_a.h = BOP.header.medium.h;
    BOP.valve_BV.port_b.h_outflow = BOP.header.medium.h;
    BOP.valve_TCV.port_b.h_outflow = BOP.header.medium.h;
    BOP.header.'port_a[1]'.h_outflow = BOP.header.medium.h;
    BOP.header.'port_b[1]'.h_outflow = BOP.header.medium.h;
    BOP.header.'port_b[2]'.h_outflow = BOP.header.medium.h;
    BOP.header.'port_b[3]'.h_outflow = BOP.header.medium.h;
    BOP.header.medium.state.h = BOP.header.medium.h;
    BOP.resistance4.port_a.h_outflow = BOP.header.medium.h;
    BOP.PID1.PID.addPID.u3 = BOP.PID1.PID.I.y;
    BOP.CS.switch_P_setpoint.u1 = BOP.CS.sensorBus.W_total;
    BOP.ED.sensorBus.W_total = BOP.CS.sensorBus.W_total;
    BOP.sensorBus.W_total = BOP.CS.sensorBus.W_total;
    BOP.generator1.Q_elec = BOP.CS.sensorBus.W_total;
    BOP.sensorW.var = BOP.CS.sensorBus.W_total;
    BOP.sensorW.W = BOP.CS.sensorBus.W_total;
    BOP.sensorW.port_a.W = BOP.CS.sensorBus.W_total;
    sinkElec.port.W = BOP.CS.sensorBus.W_total;
    BOP.resistance1.port_b.p = BOP.port_b.p;
    massFlowToPressure.fluidPort.p = BOP.port_b.p;
    BOP.resistance1.port_b.h_outflow = BOP.port_b.h_outflow;
    BOP.resistance1.state.h = BOP.port_b.h_outflow;
    BOP.steamTurbine.shaft_b.tau = BOP.steamTurbine.tau;
    BOP.powerSensor.flange_b.tau = BOP.steamTurbine.tau;
    BOP.generator1.shaft_a.tau = BOP.generator1.tau;
    BOP.powerSensor.flange_a.tau = BOP.generator1.tau;
    BOP.header.'port_a[1]'.m_flow = BOP.port_a.m_flow;
    BOP.resistance4.m_flow = BOP.port_a.m_flow;
    BOP.resistance4.port_a.m_flow = BOP.port_a.m_flow;
    BOP.CS.switch_P_setpoint.u3 = BOP.CS.W_totalSetpoint;
    BOP.CS.PID_BV_opening.u_s = BOP.CS.W_totalSetpoint;
    BOP.CS.PID_BV_opening.gain_u_s.u = BOP.CS.W_totalSetpoint;
    BOP.CS.Power_Nominal.y = BOP.CS.W_totalSetpoint;
    BOP.feedWaterHeater.port_b.m_flow = BOP.port_b.m_flow;
    BOP.resistance1.port_b.m_flow = BOP.port_b.m_flow;
    massFlowToPressure.m_flow_in = BOP.port_b.m_flow;
    BOP.CS.PID_BV_opening.y = BOP.CS.switch_BV.u1;
    BOP.CS.PID_BV_opening.limiter.y = BOP.CS.switch_BV.u1;
    BOP.CS.PID_BV_opening.addSat.u1 = BOP.CS.switch_BV.u1;
    BOP.CS.BV_opening.u1 = BOP.CS.switch_BV.y;
    BOP.CS.clock.y = BOP.CS.greater5.u1;
    BOP.CS.greater1.u1 = BOP.CS.greater5.u1;
    BOP.CS.PID_TCV_opening.gain_u_s.u = BOP.CS.PID_TCV_opening.u_s;
    BOP.CS.switch_P_setpoint_TCV.y = BOP.CS.PID_TCV_opening.u_s;
    BOP.CS.PID_TCV_opening.limiter.y = BOP.CS.PID_TCV_opening.y;
    BOP.CS.PID_TCV_opening.addSat.u1 = BOP.CS.PID_TCV_opening.y;
    BOP.CS.switch_TCV_setpoint.u1 = BOP.CS.PID_TCV_opening.y;
    BOP.CS.PID_TCV_opening.gain_u_s.y = BOP.CS.PID_TCV_opening.addP.u1;
    BOP.CS.PID_TCV_opening.addI.u1 = BOP.CS.PID_TCV_opening.addP.u1;
    BOP.CS.PID_TCV_opening.P.u = BOP.CS.PID_TCV_opening.addP.y;
    BOP.CS.PID_TCV_opening.addPID.u1 = BOP.CS.PID_TCV_opening.P.y;
    BOP.CS.PID_TCV_opening.addPID.y = BOP.CS.PID_TCV_opening.gainPID.u;
    BOP.CS.PID_TCV_opening.addFF.u2 = BOP.CS.PID_TCV_opening.gainPID.y;
    BOP.CS.PID_TCV_opening.addFF.y = BOP.CS.PID_TCV_opening.limiter.u;
    BOP.CS.PID_TCV_opening.addSat.u2 = BOP.CS.PID_TCV_opening.limiter.u;
    BOP.CS.PID_TCV_opening.addI.y = BOP.CS.PID_TCV_opening.I.u;
    BOP.CS.PID_TCV_opening.gainTrack.y = BOP.CS.PID_TCV_opening.addI.u3;
    BOP.CS.PID_TCV_opening.gainTrack.u = BOP.CS.PID_TCV_opening.addSat.y;
    BOP.CS.TCV_opening.u1 = BOP.CS.switch_TCV_setpoint.y;
    BOP.CS.PID_BV_opening.u_m = BOP.CS.switch_P_setpoint.y;
    BOP.CS.PID_BV_opening.gain_u_m.u = BOP.CS.switch_P_setpoint.y;
    BOP.CS.PID_BV_opening.gain_u_s.y = BOP.CS.PID_BV_opening.addP.u1;
    BOP.CS.PID_BV_opening.addI.u1 = BOP.CS.PID_BV_opening.addP.u1;
    BOP.CS.PID_BV_opening.gain_u_m.y = BOP.CS.PID_BV_opening.addP.u2;
    BOP.CS.PID_BV_opening.addI.u2 = BOP.CS.PID_BV_opening.addP.u2;
    BOP.CS.PID_BV_opening.P.u = BOP.CS.PID_BV_opening.addP.y;
    BOP.CS.PID_BV_opening.addPID.u1 = BOP.CS.PID_BV_opening.P.y;
    BOP.CS.PID_BV_opening.addPID.y = BOP.CS.PID_BV_opening.gainPID.u;
    BOP.CS.PID_BV_opening.addFF.u2 = BOP.CS.PID_BV_opening.gainPID.y;
    BOP.CS.PID_BV_opening.addFF.y = BOP.CS.PID_BV_opening.limiter.u;
    BOP.CS.PID_BV_opening.addSat.u2 = BOP.CS.PID_BV_opening.limiter.u;
    BOP.CS.PID_BV_opening.addI.y = BOP.CS.PID_BV_opening.I.u;
    BOP.CS.PID_BV_opening.gainTrack.y = BOP.CS.PID_BV_opening.addI.u3;
    BOP.CS.PID_BV_opening.gainTrack.u = BOP.CS.PID_BV_opening.addSat.y;
    BOP.CS.TCV_opening.y = BOP.CS.actuatorBus.opening_TCV;
    BOP.ED.actuatorBus.opening_TCV = BOP.CS.actuatorBus.opening_TCV;
    BOP.actuatorBus.opening_TCV = BOP.CS.actuatorBus.opening_TCV;
    BOP.valve_TCV.opening = BOP.CS.actuatorBus.opening_TCV;
    BOP.CS.BV_opening.y = BOP.CS.actuatorBus.opening_BV;
    BOP.ED.actuatorBus.opening_BV = BOP.CS.actuatorBus.opening_BV;
    BOP.actuatorBus.opening_BV = BOP.CS.actuatorBus.opening_BV;
    BOP.valve_BV.opening = BOP.CS.actuatorBus.opening_BV;
    BOP.steamTurbine.portHP.m_flow = BOP.steamTurbine.m_flow;
    BOP.volume.port_a.m_flow = BOP.steamTurbine.m_flow;
    BOP.valve_TCV.m_flow = BOP.steamTurbine.m_flow;
    BOP.valve_TCV.port_a.m_flow = BOP.steamTurbine.m_flow;
    BOP.steamTurbine.portHP.p = BOP.steamTurbine.p_in;
    BOP.steamTurbine.state_a.p = BOP.steamTurbine.p_in;
    BOP.valve_TCV.port_b.p = BOP.steamTurbine.p_in;
    BOP.valve_TCV.port_a.h_outflow = BOP.steamTurbine.portHP.h_outflow;
    BOP.resistance.port_a.m_flow = BOP.resistance.m_flow;
    BOP.multiPort1.'ports_b[2]'.m_flow = BOP.resistance.m_flow;
    BOP.volume.port_b.m_flow = BOP.resistance.port_b.m_flow;
    BOP.multiPort.'ports_b[1]'.m_flow = BOP.condenser.port_a.m_flow;
    BOP.multiPort1.port_a.m_flow = BOP.condenser.port_b.m_flow;
    BOP.volume.medium.state.d = BOP.volume.medium.d;
    BOP.volume.mb = BOP.volume._m_der;
    BOP.volume.Ub = BOP.volume._U_der;
    BOP.resistance2.port_b.m_flow = BOP.reservoir.port_b.m_flow;
    BOP.resistance2.port_a.p = BOP.reservoir.port_b.p;
    BOP.resistance2.state.p = BOP.reservoir.port_b.p;
    BOP.reservoir.mb = BOP.reservoir._m_der;
    BOP.reservoir.Ub = BOP.reservoir._U_der;
    BOP.reservoir.state.d = BOP.reservoir.d;
    BOP.resistance2.m_flow = BOP.feedWaterHeater.port_a.m_flow;
    BOP.resistance2.port_a.m_flow = BOP.feedWaterHeater.port_a.m_flow;
    BOP.feedWaterHeater.medium.state.d = BOP.feedWaterHeater.medium.d;
    BOP.feedWaterHeater.mb = BOP.feedWaterHeater._m_der;
    BOP.feedWaterHeater.Ub = BOP.feedWaterHeater._U_der;
    BOP.boundary.Q_flow_ext = BOP.feedWaterHeater.heatPort.Q_flow;
    BOP.PID.y = BOP.feedWaterHeater.heatPort.Q_flow;
    BOP.PID.limiter.y = BOP.feedWaterHeater.heatPort.Q_flow;
    BOP.PID.addSat.u1 = BOP.feedWaterHeater.heatPort.Q_flow;
    BOP.PID.gain_u_m.u = BOP.PID.u_m;
    BOP.temperature.var = BOP.PID.u_m;
    BOP.PID.gain_u_m.y = BOP.PID.addP.u2;
    BOP.PID.addI.u2 = BOP.PID.addP.u2;
    BOP.PID.P.u = BOP.PID.addP.y;
    BOP.PID.addPID.u1 = BOP.PID.P.y;
    BOP.PID.addPID.y = BOP.PID.gainPID.u;
    BOP.PID.addFF.u2 = BOP.PID.gainPID.y;
    BOP.PID.addFF.y = BOP.PID.limiter.u;
    BOP.PID.addSat.u2 = BOP.PID.limiter.u;
    BOP.PID.addI.y = BOP.PID.I.u;
    BOP.PID.gainTrack.y = BOP.PID.addI.u3;
    BOP.PID.gainTrack.u = BOP.PID.addSat.y;
    BOP.resistance3.m_flow = BOP.multiPort1.'ports_b[1]'.m_flow;
    BOP.resistance3.port_a.m_flow = BOP.multiPort1.'ports_b[1]'.m_flow;
    BOP.valve_BV.port_a.m_flow = BOP.valve_BV.m_flow;
    BOP.volume_bypass.port_a.m_flow = BOP.valve_BV.m_flow;
    BOP.volume_bypass.medium.state.d = BOP.volume_bypass.medium.d;
    BOP.volume_bypass.mb = BOP.volume_bypass._m_der;
    BOP.volume_bypass.Ub = BOP.volume_bypass._U_der;
    BOP.resistance3.port_b.m_flow = BOP.volume_bypass.port_b.m_flow;
    BOP.header.'port_b[1]'.m_flow = BOP.valve_BV.port_b.m_flow;
    BOP.valve_TCV.port_b.m_flow = BOP.steamTurbine.portLP.m_flow;
    BOP.header.'port_b[2]'.m_flow = BOP.steamTurbine.portLP.m_flow;
    BOP.header.medium.state.d = BOP.header.medium.d;
    BOP.header.mb = BOP.header._m_der;
    BOP.header.Ub = BOP.header._U_der;
    BOP.PID1.PID.gain_u_s.u = BOP.PID1.PID.u_s;
    BOP.PID1.PID.limiter.y = BOP.PID1.PID.y;
    BOP.PID1.PID.addSat.u1 = BOP.PID1.PID.y;
    BOP.PID1.PID.gain_u_s.y = BOP.PID1.PID.addP.u1;
    BOP.PID1.PID.addI.u1 = BOP.PID1.PID.addP.u1;
    BOP.PID1.PID.gain_u_m.y = BOP.PID1.PID.addP.u2;
    BOP.PID1.PID.addI.u2 = BOP.PID1.PID.addP.u2;
    BOP.PID1.PID.P.u = BOP.PID1.PID.addP.y;
    BOP.PID1.PID.addPID.u1 = BOP.PID1.PID.P.y;
    BOP.PID1.PID.addPID.y = BOP.PID1.PID.gainPID.u;
    BOP.PID1.PID.addFF.u2 = BOP.PID1.PID.gainPID.y;
    BOP.PID1.PID.addFF.y = BOP.PID1.PID.limiter.u;
    BOP.PID1.PID.addSat.u2 = BOP.PID1.PID.limiter.u;
    BOP.PID1.PID.addI.y = BOP.PID1.PID.I.u;
    BOP.PID1.PID.gainTrack.y = BOP.PID1.PID.addI.u3;
    BOP.PID1.PID.gainTrack.u = BOP.PID1.PID.addSat.y;
    BOP.PID1.feeBac.y = BOP.PID1.hys.u;
    BOP.PID1.y = BOP.multiPort.'ports_b[2]'.m_flow;
    BOP.boundary2.m_flow_in = BOP.multiPort.'ports_b[2]'.m_flow;
    massFlowToPressure.fluidPort.h_outflow = BOP.resistance1.port_a.h_outflow;
    BOP.resistance4.state.h = BOP.resistance4.port_b.h_outflow;
    pressureToMassFlow.fluidPort.h_outflow = BOP.resistance4.port_b.h_outflow;
    BOP.resistance4.port_a.p = BOP.port_a.p;
    BOP.resistance4.state.p = BOP.port_a.p;
    pressureToMassFlow.fluidPort.p = BOP.port_a.p;
    BOP.steamTurbine.bubble_in.p = BOP.steamTurbine.sat_in.psat;
    BOP.steamTurbine.dew_in.p = BOP.steamTurbine.sat_in.psat;
    BOP.steamTurbine.bubble_in.T = BOP.steamTurbine.sat_in.Tsat;
    BOP.steamTurbine.dew_in.T = BOP.steamTurbine.sat_in.Tsat;
    BOP.steamTurbine.bubble_out.p = BOP.steamTurbine.sat_out.psat;
    BOP.steamTurbine.dew_out.p = BOP.steamTurbine.sat_out.psat;
    BOP.steamTurbine.bubble_out.T = BOP.steamTurbine.sat_out.Tsat;
    BOP.steamTurbine.dew_out.T = BOP.steamTurbine.sat_out.Tsat;
    BOP.steamTurbine.bubble_in.h = BOP.steamTurbine.h_fsat_in;
    BOP.steamTurbine.dew_in.h = BOP.steamTurbine.h_gsat_in;
    BOP.steamTurbine.bubble_out.h = BOP.steamTurbine.h_fsat_out;
    BOP.steamTurbine.dew_out.h = BOP.steamTurbine.h_gsat_out;
    BOP.steamTurbine.eta_wetSteam.x_abs_in = BOP.steamTurbine.x_abs_in;
    BOP.steamTurbine.eta_wetSteam.x_abs_out = BOP.steamTurbine.x_abs_out;
    BOP.volume.medium.state.T = BOP.volume.medium.T;
    BOP.reservoir.state.T = BOP.reservoir.T;
    BOP.feedWaterHeater.medium.state.T = BOP.feedWaterHeater.medium.T;
    BOP.feedWaterHeater.heatPort.T = BOP.feedWaterHeater.medium.T;
    BOP.boundary.port.T = BOP.feedWaterHeater.medium.T;
    BOP.resistance1.port_a.m_flow = BOP.resistance1.m_flow;
    massFlowToPressure.fluidPort.m_flow = BOP.resistance1.m_flow;
    BOP.volume_bypass.medium.state.T = BOP.volume_bypass.medium.T;
    BOP.header.medium.state.T = BOP.header.medium.T;
    BOP.'massFlowRate[1]'.port_b.m_flow = BOP.'checkValve[1]'.port_b.m_flow;
    BOP.'specificEnthalpy[1]'.port_b.m_flow = BOP.'checkValve[1]'.port_b.m_flow;
    BOP.'boundary_a3[1]'.medium.state.phase = BOP.'boundary_a3[1]'.medium.phase;
    BOP.'boundary_m_flow_a3[1]'.medium.state.phase = BOP.'boundary_m_flow_a3[1]'.medium.phase;
    BOP.boundary2.medium.state.phase = BOP.boundary2.medium.phase;
    source1.medium.state.phase = source1.medium.phase;
    BOP.volume.medium.state.phase = BOP.volume.medium.phase;
    BOP.feedWaterHeater.medium.state.phase = BOP.feedWaterHeater.medium.phase;
    BOP.volume_bypass.medium.state.phase = BOP.volume_bypass.medium.phase;
    BOP.header.medium.state.phase = BOP.header.medium.phase;
    BOP.CS.switch_P_setpoint.u2 = BOP.CS.switch_BV.u2;
    BOP.CS.greater1.y = BOP.CS.switch_BV.u2;
    BOP.CS.switch_P_setpoint_TCV.u2 = BOP.CS.greater5.y;
    BOP.CS.switch_TCV_setpoint.u2 = BOP.CS.greater5.y;
    annotation (__Dymola_FMUImportVersion="Dymola 2021", __Dymola_FMUImportPath="C:/Users/FRICKL/Desktop/TESsystem/BOP_ME.fmu", __Dymola_FMUImportIncludeAllVariables="true", __Dymola_FMUImportIntegrate="true", experiment(StartTime=0.0, StopTime=1000.0, Tolerance=0.0001),
      Icon(graphics={
        Text(extent={{-150,150},{150,110}},
          lineColor={0,0,255},
          textString="%name"),
        Text(extent={{-150,-110},{150,-150}},
          lineColor={95,95,95},
          textString="FMI 2.0 ME")}),
  Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = BOP_ME</li>
<li>generationTool = Dymola Version 2021 (64-bit), 2020-05-13</li>
<li>generationDateAndTime = 2020-10-28T22:36:34Z</li>
</ul>
<p><br><b>Model Exchange Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>completedIntegratorStepNotNeeded = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
</html>"));
  end BOP_ME_fmu;

end FMIs;
