within NHES.Utilities.FMI_Templates.Adaptors.MSLFluidAdaptors.Examples.ReversingFlow.FMIs;
model ComponentME_fmu
  "Example model demonstrating correct functioning of fmu adaptors including at flow reversal"
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
  type Modelica_Blocks_Interfaces_RealInput = Real;
  type Modelica_Blocks_Interfaces_RealOutput = Real;
protected
  record 'system_rec'
    parameter Modelica.Units.SI.AbsolutePressure p_ambient=101325
      "Default ambient pressure";
    parameter Modelica.Units.SI.Temperature T_ambient=293.15
      "Default ambient temperature";
    parameter Modelica.Units.SI.Acceleration g=9.80665
      "Constant gravity acceleration";
    constant Boolean allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
    constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
    constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of mass balances";
    constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of substance balances";
    constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of trace substance balances";
    constant Modelica.Fluid.Types.Dynamics momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
    parameter Modelica.Units.SI.MassFlowRate m_flow_start=0
      "Default start value for mass flow rates";
    Modelica.Units.SI.AbsolutePressure p_start
      "Default start value for pressures";
    Modelica.Units.SI.Temperature T_start
      "Default start value for temperatures";
    constant Boolean use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
    Modelica.Units.SI.MassFlowRate m_flow_nominal
      "Default nominal mass flow rate";
    parameter Real eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
    parameter Modelica.Units.SI.AbsolutePressure dp_small=1
      "Default small pressure drop for regularization of laminar and zero flow";
    parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0.0) = 0.01
      "Default small mass flow rate for regularization of laminar and zero flow";
  end 'system_rec';
public
  'system_rec' 'system' annotation(Dialog);
protected
  record pressureToMassFlow_rec
    parameter Modelica.Units.SI.AbsolutePressure p_atm=100000
      "Atmospheric pressure";
    Modelica_Blocks_Interfaces_RealInput 'X_in[1]'(quantity = "MassFraction") "Prescribed mass fractions";
    Modelica_Blocks_Interfaces_RealInput 'C_in[1]' "Prescribed mass fractions";
    Modelica_Blocks_Interfaces_RealInput p_in(unit = "Pa", quantity = "Pressure") "Prescribed pressure";
    Modelica_Blocks_Interfaces_RealInput h_in(unit = "J/kg", quantity = "SpecificEnthalpy") "Prescribed specific enthalpy";
    Modelica_Blocks_Interfaces_RealOutput m_flow_out(unit = "kg/s", quantity = "MassFlowRate");
    Modelica_Blocks_Interfaces_RealOutput h_out(unit = "J/kg", quantity = "SpecificEnthalpy");
    Modelica_Blocks_Interfaces_RealOutput 'X_out[1]'(quantity = "MassFraction");
    Modelica_Blocks_Interfaces_RealOutput 'C_out[1]'(min = 0.0);
    parameter Modelica.Units.SI.SpecificEnthalpy h0_causal=0
      "Specific Enthalpy offset from causal side";
    parameter Modelica.Units.SI.SpecificEnthalpy h0_acausal=0
      "Specific Enthalpy offset on acausal side";
  protected
    record fluidPort_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end fluidPort_rec;
  public
    fluidPort_rec fluidPort;
  end pressureToMassFlow_rec;
public
  pressureToMassFlow_rec pressureToMassFlow annotation(Dialog);
protected
  record pressure_source_rec
    constant Integer nPorts = 1 "Number of ports";
    constant Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) = 101325 "Fixed value of pressure";
    constant Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) = 293.15 "Fixed value of temperature";
    constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Fixed value of composition";
    constant Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.99 "Fixed value of composition";
    constant Real 'C[1]'(quantity = "CO2", min = 0.0) = 0 "Fixed values of trace substances";
    Modelica_Blocks_Interfaces_RealInput p_in(unit = "Pa") "Prescribed boundary pressure";
    Modelica_Blocks_Interfaces_RealInput T_in(unit = "K") "Prescribed boundary temperature";
  protected
    record medium_rec
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0) "Absolute pressure of medium";
      constant Real 'Xi[1]'(quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Structurally independent mass fractions";
      Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
      Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 1.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
      Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature of medium";
      constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Mass fractions (= (component mass)/total mass  m_i/m)";
      constant Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.99 "Mass fractions (= (component mass)/total mass  m_i/m)";
      Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
      Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) "Gas constant (of mixture if applicable)";
      constant Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) = 0.02879012713067693 "Molar mass (of mixture or single fluid)";
      constant Boolean preferredMediumStates = false "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
      constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
      Modelica.Units.NonSI.Temperature_degC T_degC
        "Temperature of medium in [degC]";
      Modelica.Units.NonSI.Pressure_bar p_bar
        "Absolute pressure of medium in [bar]";
      constant Real x_water(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.010101010101010102 "Mass of total water/mass of dry air";
      Real phi "Relative humidity";
    protected
      record state_rec
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Absolute pressure of medium";
        Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature of medium";
        constant Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Mass fractions (= (component mass)/total mass  m_i/m)";
        constant Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.99 "Mass fractions (= (component mass)/total mass  m_i/m)";
      end state_rec;
    public
      state_rec state;
    end medium_rec;
  public
    medium_rec medium;
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      constant Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      constant Real 'C_outflow[1]'(min = 0.0) = 0.0 "Properties c_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  end pressure_source_rec;
public
  pressure_source_rec pressure_source;
protected
  record volumeFlowRate_rec
    constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
    Real dp_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = -1E+60, max = 100000000.0) "Guess value of dp = port_a.p - port_b.p";
    Real m_flow_start(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Guess value of m_flow = port_a.m_flow";
    Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Small mass flow rate for regularization of zero flow";
    constant Boolean show_T = true "= true, if temperatures at port_a and port_b are computed";
    constant Boolean show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
    Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -1E+60, max = 100000.0) "Mass flow rate in design flow direction";
    Modelica.Units.SI.Pressure dp
      "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
    Modelica.Units.SI.VolumeFlowRate V_flow
      "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
    Real port_a_T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature close to port_a, if show_T = true";
    Real port_b_T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature close to port_b, if show_T = true";
    parameter Real a(unit = "(Pa.s2)/m6") = 100000.0 "Coefficient for quadratic term";
    parameter Real b(unit = "(Pa.s)/m3") = 100000.0 "Coefficient for linear term";
  protected
    record port_a_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real _h_outflow_der(unit = "m2/s3") "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0)";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      constant Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      constant Real 'C_outflow[1]'(min = 0.0) = 0.0 "Properties c_i/m close to the connection point if m_flow < 0";
    end port_b_rec;
  public
    port_b_rec port_b;
  end volumeFlowRate_rec;
public
  volumeFlowRate_rec volumeFlowRate annotation(Dialog);
protected
  record volume_rec
    Modelica.Units.SI.Volume fluidVolume "Volume";
    constant Modelica.Fluid.Types.Dynamics energyDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balance";
    constant Modelica.Fluid.Types.Dynamics massDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of mass balance";
    constant Modelica.Fluid.Types.Dynamics substanceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of substance balance";
    constant Modelica.Fluid.Types.Dynamics traceDynamics = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of trace substance balance";
    Real p_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Start value of pressure";
    constant Boolean use_T_start = true "= true, use T_start, otherwise h_start";
    parameter Real _T_start_start = 288.15
    annotation(Dialog(tab = "Initial", group = "Approximate"));
    Real T_start(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0,start = _T_start_start, fixed=false) "Start value of temperature";
    Real h_start(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Start value of specific enthalpy";
    parameter Real 'X_start[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Start value of mass fractions m_i/m";
    parameter Real 'X_start[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.99 "Start value of mass fractions m_i/m";
    parameter Real 'C_start[1]'(quantity = "CO2", min = 0.0) = 0 "Start value of trace substances";
    Modelica.Units.SI.Energy U "Internal energy of fluid";
    Real _U_der(unit = "W") "der(Internal energy of fluid)";
    Modelica.Units.SI.Mass m "Mass of fluid";
    Real _m_der(unit = "kg/s") "der(Mass of fluid)";
    Modelica.Units.SI.Mass 'mXi[1]'
      "Masses of independent components in the fluid";
    Real '_mXi[1]_der'(unit = "kg/s", min = -100000.0, max = 100000.0) "der(Masses of independent components in the fluid)";
    Modelica.Units.SI.Mass 'mC[1]' "Masses of trace substances in the fluid";
    Real 'C[1]'(min = 0.0) "Trace substance mixture content";
    Modelica.Units.SI.MassFlowRate mb_flow "Mass flows across boundaries";
    Modelica.Units.SI.MassFlowRate 'mbXi_flow[1]'
      "Substance mass flows across boundaries";
    Real 'mbC_flow[1]'(unit = "kg/s") "Trace substance mass flows across boundaries";
    Modelica.Units.SI.EnthalpyFlowRate Hb_flow
      "Enthalpy flow across boundaries or energy source/sink";
    constant Modelica.Units.SI.HeatFlowRate Qb_flow=0.0
      "Heat flow across boundaries or energy source/sink";
    constant Modelica.Units.SI.Power Wb_flow=0
      "Work flow across boundaries or source term";
    parameter Real '_mC_scaled[1]_start' = 0.0
    annotation(Dialog(tab = "Initial", group = "States"));
    Real 'mC_scaled[1]'(min = 1E-15,start = '_mC_scaled[1]_start', fixed=true) "Scaled masses of trace substances in the fluid";
    constant Integer nPorts = 3 "Number of ports";
    constant Boolean use_portsData = false "= false to neglect pressure loss and kinetic energy";
    Real m_flow_nominal(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Nominal value for mass flow rates in ports";
    Modelica.Units.SI.MassFlowRate m_flow_small(min=0.0)
      "Regularization range at zero mass flow rate";
    constant Boolean use_Re = false "= true, if turbulent region is defined by Re, otherwise by m_flow_small";
    Real 'ports_H_flow[1]'(unit = "W", nominal = 1000.0, quantity = "EnthalpyFlowRate", min = -100000000.0, max = 100000000.0);
    Real 'ports_H_flow[2]'(unit = "W", nominal = 1000.0, quantity = "EnthalpyFlowRate", min = -100000000.0, max = 100000000.0);
    constant Real 'ports_H_flow[3]'(unit = "W", nominal = 1000.0, quantity = "EnthalpyFlowRate", min = -100000000.0, max = 100000000.0) = 0.0;
    Real 'ports_mXi_flow[1,1]'(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0);
    Real 'ports_mXi_flow[2,1]'(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0);
    constant Real 'ports_mXi_flow[3,1]'(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) = 0.0;
    Real 'sum_ports_mXi_flow[1]'(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Substance mass flows through ports";
    Real 'ports_mC_flow[1,1]'(unit = "kg/s");
    Real 'ports_mC_flow[2,1]'(unit = "kg/s");
    constant Real 'ports_mC_flow[3,1]'(unit = "kg/s") = 0.0;
    Real 'sum_ports_mC_flow[1]'(unit = "kg/s") "Trace substance mass flows through ports";
    constant Boolean use_HeatTransfer = false "= true to use the HeatTransfer model";
    Real 'portInDensities[1]'(unit = "kg/m3", displayUnit = "g/cm3", nominal = 1.0, quantity = "Density", min = 0.0, max = 100000.0) "densities of the fluid at the device boundary";
    Real 'portInDensities[2]'(unit = "kg/m3", displayUnit = "g/cm3", nominal = 1.0, quantity = "Density", min = 0.0, max = 100000.0) "densities of the fluid at the device boundary";
    Real 'portInDensities[3]'(unit = "kg/m3", displayUnit = "g/cm3", nominal = 1.0, quantity = "Density", min = 0.0, max = 100000.0) "densities of the fluid at the device boundary";
    constant Modelica.Units.SI.Velocity 'portVelocities[1]'=0.0
      "velocities of fluid flow at device boundary";
    constant Modelica.Units.SI.Velocity 'portVelocities[2]'=0.0
      "velocities of fluid flow at device boundary";
    constant Modelica.Units.SI.Velocity 'portVelocities[3]'=0.0
      "velocities of fluid flow at device boundary";
    constant Modelica.Units.SI.EnergyFlowRate 'ports_E_flow[1]'=0.0
      "flow of kinetic and potential energy at device boundary";
    constant Modelica.Units.SI.EnergyFlowRate 'ports_E_flow[2]'=0.0
      "flow of kinetic and potential energy at device boundary";
    constant Modelica.Units.SI.EnergyFlowRate 'ports_E_flow[3]'=0.0
      "flow of kinetic and potential energy at device boundary";
    constant Real 's[1]'(unit = "m") = 0.0 "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices";
    constant Real 's[2]'(unit = "m") = 0.0 "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices";
    constant Real 's[3]'(unit = "m") = 0.0 "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices";
    constant Real 'ports_penetration[1]' = 1.0 "penetration of port with fluid, depending on fluid level and port diameter";
    constant Real 'ports_penetration[2]' = 1.0 "penetration of port with fluid, depending on fluid level and port diameter";
    constant Real 'ports_penetration[3]' = 1.0 "penetration of port with fluid, depending on fluid level and port diameter";
    constant Modelica.Units.SI.Area 'portAreas[1]'=0.0;
    constant Modelica.Units.SI.Area 'portAreas[2]'=0.0;
    constant Modelica.Units.SI.Area 'portAreas[3]'=0.0;
    Real 'vessel_ps_static[1]'(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity";
    Real 'vessel_ps_static[2]'(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity";
    Real 'vessel_ps_static[3]'(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity";
    constant Modelica.Units.SI.ReynoldsNumber Re_turbulent=100
      "cf. suddenExpansion";
    constant Modelica.Units.SI.MassFlowRate 'm_flow_turbulent[1]'=1E+60;
    constant Modelica.Units.SI.MassFlowRate 'm_flow_turbulent[2]'=1E+60;
    constant Modelica.Units.SI.MassFlowRate 'm_flow_turbulent[3]'=1E+60;
    parameter Modelica.Units.SI.Volume V(displayUnit="l") = 0.0005 "Volume";
  protected
    record medium_rec
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0, fixed=false) "Absolute pressure of medium";
      Real 'Xi[1]'(quantity = "MassFraction", min = 0.0, max = 1.0, fixed=false) "Structurally independent mass fractions";
      Real h(unit = "J/kg", quantity = "SpecificEnergy") "Specific enthalpy of medium";
      Real d(unit = "kg/m3", displayUnit = "g/cm3", nominal = 1.0, quantity = "Density", min = 0.0, max = 100000.0) "Density of medium";
      Real _d_der(unit = "Pa.m-2.s") "der(Density of medium)";
      Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0, fixed=false) "Temperature of medium";
      Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
      Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
      Real u(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -100000000.0, max = 100000000.0) "Specific internal energy of medium";
      Real _u_der(unit = "m2/s3") "der(Specific internal energy of medium)";
      Real R(unit = "J/(kg.K)", nominal = 1000.0, quantity = "SpecificHeatCapacity", min = 0.0, max = 10000000.0) "Gas constant (of mixture if applicable)";
      Real _R_der(unit = "W/(kg.K)") "der(Gas constant (of mixture if applicable))";
      Real MM(unit = "kg/mol", nominal = 0.032, quantity = "MolarMass", min = 0.001, max = 0.25) "Molar mass (of mixture or single fluid)";
      constant Boolean preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
      constant Boolean standardOrderComponents = true "If true, and reducedX = true, the last element of X will be computed from the other ones";
      Modelica.Units.NonSI.Temperature_degC T_degC
        "Temperature of medium in [degC]";
      Modelica.Units.NonSI.Pressure_bar p_bar
        "Absolute pressure of medium in [bar]";
      Real x_water(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass of total water/mass of dry air";
      Real phi "Relative humidity";
    protected
      record state_rec
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Absolute pressure of medium";
        Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature of medium";
        Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
        Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
      end state_rec;
    public
      state_rec state;
    end medium_rec;
  public
    medium_rec medium;
  protected
    record 'ports[1]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end 'ports[1]_rec';
  public
    'ports[1]_rec' 'ports[1]';
  protected
    record 'ports[2]_rec'
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end 'ports[2]_rec';
  public
    'ports[2]_rec' 'ports[2]';
  protected
    record 'ports[3]_rec'
      constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = -0.0) = 0 "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end 'ports[3]_rec';
  public
    'ports[3]_rec' 'ports[3]';
  protected
    record heatTransfer_rec
      constant Integer n = 1 "Number of heat transfer segments";
      Modelica.Units.SI.Area 'surfaceAreas[1]' "Heat transfer areas";
      constant Modelica.Units.SI.HeatFlowRate 'Q_flows[1]'=0.0
        "Heat flow rates";
      constant Boolean use_k = false "= true to use k value for thermal isolation";
      constant Modelica.Units.SI.CoefficientOfHeatTransfer k=0
        "Heat transfer coefficient to ambient";
      Modelica.Units.SI.Temperature T_ambient "Ambient temperature";
      Modelica.Units.SI.Temperature 'Ts[1]'
        "Temperatures defined by fluid states";
    protected
      record 'states[1]_rec'
        Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Absolute pressure of medium";
        Real T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature of medium";
        Real 'X[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
        Real 'X[2]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Mass fractions (= (component mass)/total mass  m_i/m)";
      end 'states[1]_rec';
    public
      'states[1]_rec' 'states[1]';
    protected
      record 'heatPorts[1]_rec'
        Modelica.Units.SI.Temperature T "Port temperature";
        constant Modelica.Units.SI.HeatFlowRate Q_flow=0.0
          "Heat flow rate (positive if flowing from outside into the component)";
      end 'heatPorts[1]_rec';
    public
      'heatPorts[1]_rec' 'heatPorts[1]';
    end heatTransfer_rec;
  public
    heatTransfer_rec heatTransfer;
  end volume_rec;
public
  volume_rec volume annotation(Dialog);
protected
  record volumeFlowRate1_rec
    constant Boolean allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
    Real dp_start(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = -1E+60, max = 100000000.0) "Guess value of dp = port_a.p - port_b.p";
    Real m_flow_start(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Guess value of m_flow = port_a.m_flow";
    Real m_flow_small(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 100000.0) "Small mass flow rate for regularization of zero flow";
    constant Boolean show_T = true "= true, if temperatures at port_a and port_b are computed";
    constant Boolean show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
    Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -1E+60, max = 100000.0) "Mass flow rate in design flow direction";
    Modelica.Units.SI.Pressure dp
      "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
    Modelica.Units.SI.VolumeFlowRate V_flow
      "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
    Real port_a_T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature close to port_a, if show_T = true";
    Real port_b_T(unit = "K", displayUnit = "degC", nominal = 300.0, quantity = "ThermodynamicTemperature", min = 190.0, max = 647.0) "Temperature close to port_b, if show_T = true";
    parameter Real a(unit = "(Pa.s2)/m6") = 100000.0 "Coefficient for quadratic term";
    parameter Real b(unit = "(Pa.s)/m3") = 100000.0 "Coefficient for linear term";
  protected
    record port_a_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -1E+60, max = 100000.0) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end port_a_rec;
  public
    port_a_rec port_a;
  protected
    record port_b_rec
      Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = -100000.0, max = 1E+60) "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      Real 'C_outflow[1]'(min = 0.0) "Properties c_i/m close to the connection point if m_flow < 0";
    end port_b_rec;
  public
    port_b_rec port_b;
  end volumeFlowRate1_rec;
public
  volumeFlowRate1_rec volumeFlowRate1 annotation(Dialog);
protected
  record temperature_rec
    Modelica_Blocks_Interfaces_RealOutput T(unit = "K", displayUnit = "degC", quantity = "ThermodynamicTemperature", min = 0.0) "Temperature in port medium";
  protected
    record port_rec
      constant Real m_flow(unit = "kg/s", quantity = "MassFlowRate.Moist air", min = 0.0, max = 100000.0) = 0.0 "Mass flow rate from the connection point into the component";
      Real p(unit = "Pa", displayUnit = "bar", nominal = 100000.0, quantity = "Pressure", min = 0.0, max = 100000000.0) "Thermodynamic pressure in the connection point";
      constant Real h_outflow(unit = "J/kg", nominal = 1000000.0, quantity = "SpecificEnergy", min = -10000000000.0, max = 10000000000.0) = 45263.238744693415 "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
      constant Real 'Xi_outflow[1]'(nominal = 0.1, quantity = "MassFraction", min = 0.0, max = 1.0) = 0.01 "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
      constant Real 'C_outflow[1]'(min = 0.0) = 0.0 "Properties c_i/m close to the connection point if m_flow < 0";
    end port_rec;
  public
    port_rec port annotation(Dialog);
  end temperature_rec;
public
  temperature_rec temperature annotation(Dialog);
  parameter Real _T_source_start = 288.15
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput T_source(unit = "K", nominal = 300.0, min = 190.0, max = 647.0, start = _T_source_start) "Prescribed boundary temperature"
  annotation (Placement(transformation(extent={{-114,62},{-94,82}})));
  parameter Real _p_source_start = 100000.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput p_source(unit = "Pa", nominal = 100000.0, min = 0.0, max = 100000000.0, start = _p_source_start) "Prescribed boundary pressure"
  annotation (Placement(transformation(extent={{-114,33},{-94,53}})));
  parameter Real _C_in_1__start = 1.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput C_in_1_(min = 0.0, start = _C_in_1__start) "Prescribed mass fractions"
  annotation (Placement(transformation(extent={{-114,5},{-94,25}})));
  parameter Real _X_in_1__start = 0.01
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput X_in_1_(nominal = 0.1, min = 0.0, max = 1.0, start = _X_in_1__start) "Prescribed mass fractions"
  annotation (Placement(transformation(extent={{-114,-24},{-94,-4}})));
  parameter Real _h_in_start = 0.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput h_in(unit = "J/kg", start = _h_in_start) "Prescribed specific enthalpy"
  annotation (Placement(transformation(extent={{-114,-52},{-94,-32}})));
  parameter Real _p_in_start = 100000.0
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput p_in(unit = "Pa", nominal = 100000.0, min = 0.0, max = 100000000.0, start = _p_in_start) "Prescribed pressure"
  annotation (Placement(transformation(extent={{-114,-81},{-94,-61}})));
  Modelica.Blocks.Interfaces.RealOutput C_out_1_(min = 0.0)
  annotation (Placement(transformation(extent={{100,65},{120,85}})));
  Modelica.Blocks.Interfaces.RealOutput X_out_1_(nominal = 0.1, min = 0.0, max = 1.0)
  annotation (Placement(transformation(extent={{100,40},{120,60}})));
  Modelica.Blocks.Interfaces.RealOutput h_out(unit = "J/kg")
  annotation (Placement(transformation(extent={{100,15},{120,35}})));
  Modelica.Blocks.Interfaces.RealOutput m_flow_out(unit = "kg/s", min = -100000.0, max = 100000.0)
  annotation (Placement(transformation(extent={{100,-10},{120,10}})));
  Modelica.Blocks.Interfaces.RealOutput Temperature(unit = "K", min = 0.0) "Temperature in port medium"
  annotation (Placement(transformation(extent={{100,-35},{120,-15}})));
  Modelica.Blocks.Interfaces.RealOutput CPUtime(unit = "s")
  annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
  Modelica.Blocks.Interfaces.RealOutput EventCounter
  annotation (Placement(transformation(extent={{100,-85},{120,-65}})));
public
  parameter String fmi_instanceName="ComponentME_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  constant Integer fmi_NumberOfEventIndicators = 20;
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real zeroOffset = 0; //will fix in later implementations
  Boolean fmi_NewStates;
  Boolean fmi_StepEvent;
  Boolean fmi_DiscreteInputChanged;
  Boolean fmi_iterationConverged(start=false, fixed=true);
  Integer fmi_NextMode;
  Boolean fmi_flip(start=false, fixed=true);
  Real fmi_TNext(start=1e37, fixed=true);
  Real myTime;
  parameter Real myTimeStart(fixed=false);
  Boolean _first(start=true);
  parameter Boolean _startValuesNotSet(fixed=false,start=true);
  Real fmi_dummy;
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = ComponentME8526794111893887762214_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Header="
#ifndef ComponentME8526794111893887762214_Instantiate_C
#define ComponentME8526794111893887762214_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void ComponentME8526794111893887762214Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * ComponentME8526794111893887762214_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&ComponentME8526794111893887762214Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"ComponentME.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (ComponentME.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmi2SetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2SetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmi2GetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmi2GetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmi2SetTimeFunc)GetProcAddress(res->hInst,\"fmi2SetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmi2CompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmi2CompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2CompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterEventMode=(fmi2EnterEventModeFunc)GetProcAddress(res->hInst,\"fmi2EnterEventMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterEventMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterEventMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiNewDiscreteStates=(fmi2NewDiscreteStatesFunc)GetProcAddress(res->hInst,\"fmi2NewDiscreteStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2NewDiscreteStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiNewDiscreteStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEnterContinuousTimeMode=(fmi2EnterContinuousTimeModeFunc)GetProcAddress(res->hInst,\"fmi2EnterContinuousTimeMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterContinuousTimeMode!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEnterContinuousTimeMode\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmi2GetDerivativesFunc)GetProcAddress(res->hInst,\"fmi2GetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmi2GetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmi2GetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDirectionalDerivative=(fmi2GetDirectionalDerivativeFunc)GetProcAddress(res->hInst,\"fmi2GetDirectionalDerivative\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetDirectionalDerivative!\");
      return 0;
    }
    if (!(res->dyFmiGetFMUstate=(fmi2GetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2GetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSetFMUstate=(fmi2SetFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SetFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiFreeFMUstate=(fmi2FreeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2FreeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiSerializedFMUstateSize=(fmi2SerializedFMUstateSizeFunc)GetProcAddress(res->hInst,\"fmi2SerializedFMUstateSize\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializedFMUstateSize!\");
      return 0;
    }
    if (!(res->dyFmiSerializeFMUstate=(fmi2SerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2SerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SerializeFMUstate!\");
      return 0;
    }
    if (!(res->dyFmiDeSerializeFMUstate=(fmi2DeSerializeFMUstateFunc)GetProcAddress(res->hInst,\"fmi2DeSerializeFMUstate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2DeSerializeFMUstate!\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2ModelExchange, \"{8a5e26e7-9fac-4111-89b3-8b87cd762214}\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   ComponentME8526794111893887762214_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_Free_C
#define ComponentME8526794111893887762214_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void ComponentME8526794111893887762214_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    if(a->dyFMUstate)
    a->dyFmiFreeFMUstate(a->m, &a->dyFMUstate);
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
      end destructor;
    end fmiModel;

    function fmiSetTime
    input fmiModel fmi;
    input Real ti;
    external"C" ComponentME8526794111893887762214_fmiSetTime2(fmi, ti);
    annotation (Header="
#ifndef ComponentME8526794111893887762214_SetTime_C
#define ComponentME8526794111893887762214_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetTime2(void*m, double ti) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(ti > a->dyTime || (a->currentMode == dyfmi2EventMode && ti==a->dyTime && !isModelicaEvent())){
      a->dyTime=ti;
      if(a->currentMode == dyfmi2EventMode){
        status = a->dyFmiEnterContinuousTimeMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterContinuousTimeMode failed!\");
        a->currentMode = dyfmi2ContinuousTimeMode;
      }
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti < a->dyTime && a->currentMode == dyfmi2ContinuousTimeMode){
       a->dyTime=ti;
       status=a->dyFmiSetTime(a->m, ti);
    }else{
       status=fmi2OK;
    }
  }
  if (status!=fmi2OK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true);
    end fmiSetTime;

    function fmiSetContinuousStates
    input fmiModel fmi;
    input Real x[:];
      external"C" ComponentME8526794111893887762214_fmiSetContinuousStates2(
       fmi,
       x,
       size(x, 1));
      annotation (Header="
#ifndef ComponentME8526794111893887762214_SetContinuousStates_C
#define ComponentME8526794111893887762214_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
     status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
     status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiSetContinuousStates;

    function fmiGetContinuousStates
    input fmiModel fmi;
    input Integer nx;
    output Real x[nx];
    input Real preAvailable;
      external"C" ComponentME8526794111893887762214_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetContinuousStates_C
#define ComponentME8526794111893887762214_GetContinuousStates_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void ComponentME8526794111893887762214_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetContinuousStates;

    function fmiCompletedIntegratorStep
    input fmiModel fmi;
    input Real dummyTime;
    output Real crossing;
      external"C" crossing = ComponentME8526794111893887762214_fmiCompletedIntegratorStep2(fmi);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_CompletedIntegratorStep_C
#define ComponentME8526794111893887762214_CompletedIntegratorStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double ComponentME8526794111893887762214_fmiCompletedIntegratorStep2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status = fmi2Fatal;
  fmi2Boolean enterEventMode = fmi2False;
  fmi2Boolean terminateSimulation = fmi2False;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      status=a->dyFmiCompletedIntegratorStep(a->m, fmi2True, &enterEventMode, &terminateSimulation);
      if(terminateSimulation == fmi2True) terminate(\"Terminate signaled by FMU after call to fmiCompletedIntegratorStep\");
      a->dyLastTime=a->dyTime;
      if (enterEventMode == fmi2True) a->dyTriggered=1;
    } else status=fmi2OK;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiCompletedIntegratorStep;

    function fmiEnterModelInitialization
    input fmiModel fmi;
    input Real startTime;
    external"C" ComponentME8526794111893887762214_fmiEnterModelInitialization2(fmi, startTime);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiEnterModelInitialization_C
#define ComponentME8526794111893887762214_fmiEnterModelInitialization_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiEnterModelInitialization2(void*m, double startTime) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean toleranceControlled=fmi2False;
  fmi2Real tolerance=0;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      a->dyTime=startTime;
      status=a->dyFmiSetupExperiment(a->m, fmi2False, 0, a->dyTime, fmi2False, 0);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->currentMode=dyfmi2InitializationMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"Initialize failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiEnterModelInitialization;

    function fmiExitModelInitializationMode
    input fmiModel fmi;
    output Real dummy=1.0;
    external"C" ComponentME8526794111893887762214_fmiExitModelInitializationMode2(fmi);
    annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiExitModelInitializationMode_C
#define ComponentME8526794111893887762214_fmiExitModelInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiExitModelInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiExitModelInitializationMode;

    function fmiUpdateDiscreteStates
    input fmiModel fmi;
    output Integer nextMode;
    output Real tNext;
    output Boolean stateValuesChanged;
    external"C" nextMode = ComponentME8526794111893887762214_fmiUpdateDiscreteStates2(fmi, tNext, stateValuesChanged);
      annotation(Header="
#ifndef ComponentME8526794111893887762214_UpdateDiscreteStates_C
#define ComponentME8526794111893887762214_UpdateDiscreteStates_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
int ComponentME8526794111893887762214_fmiUpdateDiscreteStates2(void*m, double* tNext, int* stateValuesChanged){
  struct dy_fmi2Extended*a=m;
  fmi2EventInfo ev;
  fmi2Status status=fmi2Fatal;
  ev.nextEventTime=1e37;
  ev.newDiscreteStatesNeeded=fmi2False;
  ev.valuesOfContinuousStatesChanged=fmi2False;
  ev.nextEventTimeDefined=fmi2False;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
  status=a->dyFmiNewDiscreteStates(a->m, &ev);
  a->dyTriggered=0;
  a->dyLastTime=a->dyTime;
  a->discreteInputChanged=0;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"EventUpdate failed\");
  if (ev.terminateSimulation){
    terminate(\"Terminate signaled by FMU\");
  }
  if(ev.nextEventTimeDefined==fmi2True){
    *tNext=ev.nextEventTime;
  }else{
    *tNext=1e37;
  }
  *stateValuesChanged = ev.valuesOfContinuousStatesChanged;
  return ev.newDiscreteStatesNeeded;
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiUpdateDiscreteStates;

    function fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" ComponentME8526794111893887762214_fmiGetDerivatives2(
    fmi,
      dx,
      nx);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetDerivatives_C
#define ComponentME8526794111893887762214_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetDerivatives;

    function fmiGetEventIndicators
    input fmiModel fmi;
    input Integer nz;
    output Real z[nz];
    external"C" ComponentME8526794111893887762214_fmiGetEventIndicators2(
      fmi,
      z,
      nz);
    annotation (Header="
#ifndef ComponentME8526794111893887762214_GetEventIndicators_C
#define ComponentME8526794111893887762214_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode || a->currentMode == dyfmi2EventMode){
      status=a->dyFmiGetEventIndicators(a->m, z, nz);
    }else{
      status=fmi2OK;    }
;  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetEventIndicators;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = ComponentME8526794111893887762214_fmiReset2(fmi);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_Reset_C
#define ComponentME8526794111893887762214_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double ComponentME8526794111893887762214_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetReal_C
#define ComponentME8526794111893887762214_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetReal_C
#define ComponentME8526794111893887762214_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 ComponentME8526794111893887762214_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_SetReal_C
#define ComponentME8526794111893887762214_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 ComponentME8526794111893887762214_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_SetReal_C
#define ComponentME8526794111893887762214_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetInteger_C
#define ComponentME8526794111893887762214_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetInteger_C
#define ComponentME8526794111893887762214_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void ComponentME8526794111893887762214_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_SetInteger_C
#define ComponentME8526794111893887762214_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_GetBoolean_C
#define ComponentME8526794111893887762214_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_GetBoolean_C
#define ComponentME8526794111893887762214_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_SetBoolean_C
#define ComponentME8526794111893887762214_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" ComponentME8526794111893887762214_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_SetString_C
#define ComponentME8526794111893887762214_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiGetDirectionalDerivative
      input fmiModel fmi;
      input Integer z_refs[:];
      input Integer v_refs[:];
      input Real dv[size(v_refs, 1)];
      output Real dz[size(z_refs, 1)];
      external"C" ComponentME8526794111893887762214_GetDirectionalDerivative2(
        fmi,
        z_refs,
        size(z_refs, 1),
        v_refs,
        size(v_refs, 1),
        dv,
        dz);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_GetDirectionalDerivative2_C
#define ComponentME8526794111893887762214_GetDirectionalDerivative2_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_GetDirectionalDerivative2(void*m, const int* zref, size_t nzr, const int* vrefs, size_t nvr, const double *dv, double *dz) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetDirectionalDerivative(a->m, zref, nzr, vrefs, nvr, dv, dz);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetDirectionalDerivative failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiGetDirectionalDerivative;

    function CheckIfDiscreteValueSet
      input fmiModel fmi;
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Real dummyRealOutputs[:];
      input Boolean dummyBooleanOutputs[:];
      input Integer dummyIntegerOutputs[:];
      output Real DiscreteInputSet;
    algorithm
      fmiSetReal(fmi, realInputValueReferences, realInputs);
      fmiSetBoolean(fmi, booleanInputValueReferences, booleanInputs);
      fmiSetInteger(fmi, integerInputValueReferences, integerInputs);
      DiscreteInputSet := fmiCheckIfDiscreteValueSet(fmi);
      annotation(LateInline=true);
    end CheckIfDiscreteValueSet;

    function fmiCheckIfDiscreteValueSet
      input fmiModel fmi;
      output Real DiscreteInputSet;
      external "C" DiscreteInputSet = ComponentME8526794111893887762214_fmiCheckIfDiscreteValueSet2(fmi);
      annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiCheckIfDiscreteValueSet_C
#define ComponentME8526794111893887762214_fmiCheckIfDiscreteValueSet_C 1
#include \"FMI/fmi2Import.h\"
double ComponentME8526794111893887762214_fmiCheckIfDiscreteValueSet2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    return a->discreteInputChanged;
  }
  ModelicaError(\"fmiCheckIfDiscreteValueSet2 failed!\");
  return 0;
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiCheckIfDiscreteValueSet;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputVariableReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(derivative(noDerivative=realLinearDependentInputs,noDerivative=linearDependentStates)=derGetRealVariable, LateInline=true);
    end GetRealVariable;

    function derGetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      input Real derRealInputs[:];
      input Real derStates[:];
      input Real derLinearOffsets;
      output Real derOutputVariable;
    protected
      Real dummy[1];
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //setString(fmi,stringInputValueReferences,stringInputs);
      dummy:=fmiGetDirectionalDerivative(fmi, outputValueReference,  cat(1,realInputValueReferences,statesValueRefernces), cat(1,derRealInputs,derStates));
      derOutputVariable:=dummy[1]+derLinearOffsets;
      annotation(LateInline=true);
    end derGetRealVariable;

    function fmiSaveFMUState
      input fmiModel fmi;
      external"C" ComponentME8526794111893887762214_fmiSaveFMUState2(fmi);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiSaveFMUState_C
#define ComponentME8526794111893887762214_fmiSaveFMUState_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSaveFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiSaveFMUState;

    function fmiRestoreFMUState
      input fmiModel fmi;
      external"C" ComponentME8526794111893887762214_fmiRestoreFMUState2(fmi);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiRestoreFMUState_C
#define ComponentME8526794111893887762214_fmiRestoreFMUState_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiRestoreFMUState2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiRestoreFMUState;

    function fmiSerializeFMUstate
      input fmiModel fmi;
      external"C" ComponentME8526794111893887762214_fmiSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiSerializeFMUstate_C
#define ComponentME8526794111893887762214_fmiSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status = a->dyFmiGetFMUstate(a->m, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiGetFMUstate failed\");
    status = a->dyFmiSerializedFMUstateSize(a->m, a->dyFMUstate, &a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializedFMUstateSize failed\");
    if( a->dySerializeFMUstate) free(a->dySerializeFMUstate); a->dySerializeFMUstate = NULL;
    a->dySerializeFMUstate = malloc(a->dyFMUStateSize);
    if(!a->dySerializeFMUstate)  ModelicaError(\"malloc call to allocate SerializeFMUstate failed\");
    status = a->dyFmiSerializeFMUstate(a->m, a->dyFMUstate, a->dySerializeFMUstate, a->dyFMUStateSize);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSerializeFMUstate failed\");
  }
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiSerializeFMUstate;

    function fmiDeSerializeFMUstate
      input fmiModel fmi;
      external"C" ComponentME8526794111893887762214_fmiDeSerializeFMUstate2(fmi);
        annotation (Header="
#ifndef ComponentME8526794111893887762214_fmiDeSerializeFMUstate_C
#define ComponentME8526794111893887762214_fmiDeSerializeFMUstate_C 1
#include \"FMI/fmi2Import.h\"
void ComponentME8526794111893887762214_fmiDeSerializeFMUstate2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(!a->dySerializeFMUstate) ModelicaError(\"serializedFmuState is not allocated!!!\");
    if(a->dyFMUstate){
      a->dyFmiFreeFMUstate(a->m, a->dyFMUstate);
      a->dyFMUstate = NULL;    }
    status = a->dyFmiDeSerializeFMUstate(a->m, a->dySerializeFMUstate, a->dyFMUStateSize, &a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiDeSerializeFMUstate failed\");
    status = a->dyFmiSetFMUstate(a->m, a->dyFMUstate);
    if (status != fmi2OK && status != fmi2Warning) ModelicaError(\"fmiSetFMUstate failed\");
  }
}
#endif", Library="ComponentME", LibraryDirectory="modelica://ComponentME_fmu/Resources/Library/FMU/ComponentME/binaries", __Dymola_CriticalRegion="ComponentME");
    end fmiDeSerializeFMUstate;

    function setTimeAndStates
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      output Real tOut=Time;
    algorithm
      fmiSetTime(fmu, Time);
      fmiSetContinuousStates(fmu,States);
      annotation(derivative(noDerivative=dummy,noDerivative=States)=dTS);
    end setTimeAndStates;

    function dTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      output Real dt;
    algorithm
      dt:=1;
      annotation(derivative(order=2)=ddTS);
    end dTS;

    function ddTS
      input fmiModel fmu;
      input Real Time;
      input Real States[:];
      input Real dummy;
      input Real dTime;
      input Real ddTime;
      output Real ddt;
    algorithm
      ddt:=0;
    end ddTS;
end fmi_Functions;
algorithm
  when initial() then
    if _first then
      _first := false;
      fmi := fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
    end if;
  end when;
initial algorithm
  if _startValuesNotSet then
  fmi_Functions.fmiSetReal(fmi, {16777216, 16777217, 16777218, 16777219, 16777220, 16777221, 16777222, 16777223, 16777224, 16777225, 16777227, 16777228, 16777233, 16777234, 16777235, 16777238, 16777240, 16777241}, {'system'.p_ambient, 'system'.T_ambient, 'system'.g, 'system'.m_flow_start, 'system'.eps_m_flow, 'system'.dp_small, 'system'.m_flow_small, pressureToMassFlow.p_atm, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volumeFlowRate.a, volumeFlowRate.b, volume.'X_start[1]', volume.'X_start[2]', volume.'C_start[1]', volume.V, volumeFlowRate1.a, volumeFlowRate1.b});
  fmi_Functions.fmiSetReal(fmi, {100663387, 33554435}, {volume._T_start_start, volume.'_mC_scaled[1]_start'});
  fmi_Functions.fmiSetReal(fmi, {352321536, 352321537, 352321538, 352321539, 352321540, 352321541}, {_T_source_start, _p_source_start, _C_in_1__start, _X_in_1__start, _h_in_start, _p_in_start});
  fmi_Functions.fmiEnterModelInitialization(fmi, time);
  _startValuesNotSet :=false;
  end if;
  myTimeStart := time;
equation
  when not initial() then
    fmi_dummy = fmi_Functions.fmiExitModelInitializationMode(fmi);
  {'system'.p_start, 'system'.T_start, 'system'.m_flow_nominal, volumeFlowRate.dp_start, volumeFlowRate.m_flow_start, volumeFlowRate.m_flow_small, volume.p_start, volume.T_start, volume.h_start, volume.m_flow_nominal, volume.m_flow_small, volume.heatTransfer.'surfaceAreas[1]', volume.heatTransfer.T_ambient, volumeFlowRate1.dp_start, volumeFlowRate1.m_flow_start, volumeFlowRate1.m_flow_small} = fmi_Functions.fmiGetRealwf(fmi, {100663302, 100663303, 100663305, 100663361, 100663362, 100663363, 100663385, 100663387, 100663388, 100663428, 100663429, 100663442, 100663446, 100663494, 100663495, 100663496}, fmi_dummy);
  end when;
  myTime = fmi_Functions.setTimeAndStates(fmi, time, {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T, volume.'mC_scaled[1]'}, fmi_dummy);
  fmi_StepEvent = fmi_Functions.fmiCompletedIntegratorStep(fmi, myTime)>0.5;
  fmi_DiscreteInputChanged= fmi_Functions.CheckIfDiscreteValueSet(fmi, myTime, {T_source, p_source, C_in_1_, X_in_1_, h_in, p_in}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), {C_out_1_, X_out_1_, h_out, m_flow_out, Temperature, CPUtime, EventCounter}, fill(false,0), fill(0,0))  > 0.5;
  fmi_flip = ( if ( fmi_DiscreteInputChanged or not pre(fmi_iterationConverged)) then not pre(fmi_flip) else pre(fmi_flip));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {T_source, p_source, C_in_1_, X_in_1_, h_in, p_in}, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_flip, not fmi_flip, fmi_StepEvent}) then
    (fmi_NextMode, fmi_TNext, fmi_NewStates) =  fmi_Functions.fmiUpdateDiscreteStates(fmi);
    fmi_iterationConverged = if fmi_NextMode == 0 then true else false;
  end when;
initial equation
  volume.medium.p = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, volume.'X_start[1]', volume.'X_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777233, 16777234}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554432});
  volume.medium.'Xi[1]' = fmi_Functions.GetRealVariable(fmi, myTimeStart, {volume.'X_start[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777233}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554433});
  volume.medium.T = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, volume.'X_start[1]', volume.'X_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777233, 16777234}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {33554434});
equation
  if initial() then
    der(volume.medium.p) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, 'system'.eps_m_flow, 'system'.m_flow_small, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volumeFlowRate.a, volumeFlowRate.b, volume.'X_start[1]', volume.'X_start[2]', volume.V, volumeFlowRate1.a, volumeFlowRate1.b, T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777220, 16777222, 16777224, 16777225, 16777227, 16777228, 16777233, 16777234, 16777238, 16777240, 16777241, 352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202560});
  else
    der(volume.medium.p) = fmi_Functions.GetRealVariable(fmi, myTime, {T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {587202560});
  end if;
  if initial() then
    der(volume.medium.'Xi[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, 'system'.eps_m_flow, 'system'.m_flow_small, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volumeFlowRate.a, volumeFlowRate.b, volume.'X_start[1]', volume.'X_start[2]', volume.V, volumeFlowRate1.a, volumeFlowRate1.b, T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777220, 16777222, 16777224, 16777225, 16777227, 16777228, 16777233, 16777234, 16777238, 16777240, 16777241, 352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202561});
  else
    der(volume.medium.'Xi[1]') = fmi_Functions.GetRealVariable(fmi, myTime, {T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {587202561});
  end if;
  if initial() then
    der(volume.medium.T) = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, 'system'.eps_m_flow, 'system'.m_flow_small, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volumeFlowRate.a, volumeFlowRate.b, volume.'X_start[1]', volume.'X_start[2]', volume.V, volumeFlowRate1.a, volumeFlowRate1.b, T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777220, 16777222, 16777224, 16777225, 16777227, 16777228, 16777233, 16777234, 16777238, 16777240, 16777241, 352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202562});
  else
    der(volume.medium.T) = fmi_Functions.GetRealVariable(fmi, myTime, {T_source, p_source, X_in_1_, h_in, p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321539, 352321540, 352321541}, fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {587202562});
  end if;
  if initial() then
    der(volume.'mC_scaled[1]') = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, 'system'.eps_m_flow, 'system'.m_flow_small, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volumeFlowRate.a, volumeFlowRate.b, volume.'X_start[1]', volume.'X_start[2]', volume.'mC_scaled[1]', volume.V, volumeFlowRate1.a, volumeFlowRate1.b, T_source, p_source, C_in_1_, X_in_1_, h_in, p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777220, 16777222, 16777224, 16777225, 16777227, 16777228, 16777233, 16777234, 33554435, 16777238, 16777240, 16777241, 352321536, 352321537, 352321538, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {587202563});
  else
    der(volume.'mC_scaled[1]') = fmi_Functions.GetRealVariable(fmi, myTime, {T_source, p_source, C_in_1_, X_in_1_, h_in, p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T, volume.'mC_scaled[1]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321536, 352321537, 352321538, 352321539, 352321540, 352321541}, fill(0,0), {33554432, 33554433, 33554434, 33554435}, fill(0,0), fill(0,0), {587202563});
  end if;
  if initial() then
    C_out_1_ = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, volume.'X_start[1]', volume.'X_start[2]', volume.'mC_scaled[1]', volume.V}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777233, 16777234, 33554435, 16777238}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544320});
  else
    C_out_1_ = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T, volume.'mC_scaled[1]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554433, 33554434, 33554435}, fill(0,0), fill(0,0), {335544320});
  end if;
  if initial() then
    X_out_1_ = fmi_Functions.GetRealVariable(fmi, myTimeStart, {volume.'X_start[1]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777233}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544321});
  else
    X_out_1_ = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {volume.medium.'Xi[1]'}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554433}, fill(0,0), fill(0,0), {335544321});
  end if;
  if initial() then
    h_out = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volume.'X_start[1]', volume.'X_start[2]', p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777224, 16777225, 16777233, 16777234, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544322});
  else
    h_out = fmi_Functions.GetRealVariable(fmi, myTime, {p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321541}, fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {335544322});
  end if;
  if initial() then
    m_flow_out = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, 'system'.eps_m_flow, 'system'.m_flow_small, pressureToMassFlow.h0_causal, pressureToMassFlow.h0_acausal, volume.'X_start[1]', volume.'X_start[2]', volumeFlowRate1.a, volumeFlowRate1.b, X_in_1_, h_in, p_in}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777220, 16777222, 16777224, 16777225, 16777233, 16777234, 16777240, 16777241, 352321539, 352321540, 352321541}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544323});
  else
    m_flow_out = fmi_Functions.GetRealVariable(fmi, myTime, {X_in_1_, h_in, p_in}, fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {352321539, 352321540, 352321541}, fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {335544323});
  end if;
  if initial() then
    Temperature = fmi_Functions.GetRealVariable(fmi, myTimeStart, {'system'.p_ambient, 'system'.T_ambient, volume.'X_start[1]', volume.'X_start[2]'}, fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), {16777216, 16777217, 16777233, 16777234}, fill(0,0), fill(0,0), fill(0,0), fill(0,0), {335544324});
  else
    Temperature = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), {volume.medium.p, volume.medium.'Xi[1]', volume.medium.T}, fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), {33554432, 33554433, 33554434}, fill(0,0), fill(0,0), {335544324});
  end if;
  if initial() then
    CPUtime = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {integer(2214592517)});
  else
    CPUtime = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {integer(2214592517)});
  end if;
  if initial() then
    EventCounter = fmi_Functions.GetRealVariable(fmi, myTimeStart, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {integer(2214592518)});
  else
    EventCounter = fmi_Functions.GetRealVariable(fmi, myTime, fill(0.0,0), fill(0.0,0), fill(0.0,0), fill(0.0,0), zeroOffset, fill(false,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), fill(0,0), {integer(2214592518)});
  end if;
{pressureToMassFlow.'X_in[1]', pressureToMassFlow.'C_in[1]', pressureToMassFlow.p_in, pressureToMassFlow.h_in, pressureToMassFlow.'X_out[1]', pressureToMassFlow.fluidPort.h_outflow, pressure_source.p_in, pressure_source.T_in, pressure_source.medium.h, pressure_source.medium.d, pressure_source.medium.u, pressure_source.medium.R, pressure_source.medium.T_degC, pressure_source.medium.p_bar, pressure_source.medium.phi, pressure_source.'ports[1]'.m_flow, volumeFlowRate.m_flow, volumeFlowRate.dp, volumeFlowRate.V_flow, volumeFlowRate.port_a_T, volumeFlowRate.port_b_T, volumeFlowRate.port_a.h_outflow, volumeFlowRate.port_a._h_outflow_der, volumeFlowRate.port_b.p, volume.fluidVolume, volume.U, volume._U_der, volume.m, volume._m_der, volume.'mXi[1]', volume.'_mXi[1]_der', volume.'mC[1]', volume.'mbC_flow[1]', volume.'ports_H_flow[1]', volume.'ports_H_flow[2]', volume.'ports_mXi_flow[1,1]', volume.'ports_mXi_flow[2,1]', volume.'ports_mC_flow[1,1]', volume.'ports_mC_flow[2,1]', volume.'portInDensities[1]', volume.'portInDensities[2]', volume.'portInDensities[3]', volume.medium.d, volume.medium._d_der, volume.medium.'X[2]', volume.medium.u, volume.medium._u_der, volume.medium.R, volume.medium._R_der, volume.medium.MM, volume.medium.T_degC, volume.medium.p_bar, volume.medium.x_water, volume.medium.phi, volume.'ports[2]'.m_flow, volume.'ports[2]'.p, volumeFlowRate1.dp, volumeFlowRate1.V_flow, volumeFlowRate1.port_a_T, volumeFlowRate1.port_b_T, volumeFlowRate1.port_a.'Xi_outflow[1]'} = fmi_Functions.fmiGetRealwf(fmi, {436207619, 436207618, 436207621, 436207620, 369098765, 369098762, 436207617, 436207616, 637534250, 905969685, 905969688, 905969689, 905969695, 905969696, 905969698, 637534249, 637534336, 637534278, 905969735, 905969736, 905969737, 369098811, 637534268, 369098830, 234881046, 905969781, 637534326, 369098871, 637534328, 905969785, 637534330, 369098875, 637534332, 637534343, 637534344, 637534346, 637534347, 637534349, 637534350, 905969816, 905969817, 905969818, 369098845, 637534302, 905969759, 637534304, 637534305, 369098850, 637534307, 905969764, 905969767, 905969768, 905969769, 905969770, 369098881, 369098959, 369098955, 905969868, 905969869, 905969870, 905969859}, if initial() then myTimeStart else myTime);
//alias Declarations
  volume.'vessel_ps_static[1]' = volume.medium.p;
  volume.'vessel_ps_static[2]' = volume.medium.p;
  volume.'vessel_ps_static[3]' = volume.medium.p;
  volume.medium.state.p = volume.medium.p;
  volume.heatTransfer.'states[1]'.p = volume.medium.p;
  pressureToMassFlow.'C_out[1]' = C_out_1_;
  volumeFlowRate.port_a.'C_outflow[1]' = C_out_1_;
  volume.'C[1]' = C_out_1_;
  volume.'ports[1]'.'C_outflow[1]' = C_out_1_;
  volume.'ports[2]'.'C_outflow[1]' = C_out_1_;
  volume.'ports[3]'.'C_outflow[1]' = C_out_1_;
  volumeFlowRate1.port_b.'C_outflow[1]' = C_out_1_;
  pressureToMassFlow.h_out = h_out;
  pressureToMassFlow.m_flow_out = m_flow_out;
  pressureToMassFlow.fluidPort.m_flow = m_flow_out;
  volumeFlowRate1.m_flow = m_flow_out;
  volumeFlowRate1.port_a.m_flow = m_flow_out;
  temperature.T = Temperature;
  volume.medium.state.T = volume.medium.T;
  volume.heatTransfer.'Ts[1]' = volume.medium.T;
  volume.heatTransfer.'states[1]'.T = volume.medium.T;
  volume.heatTransfer.'heatPorts[1]'.T = volume.medium.T;
  volumeFlowRate1.port_a.h_outflow = pressureToMassFlow.fluidPort.h_outflow;
  volumeFlowRate.port_a.'Xi_outflow[1]' = pressureToMassFlow.'X_out[1]';
  volume.medium.'X[1]' = pressureToMassFlow.'X_out[1]';
  volume.medium.state.'X[1]' = pressureToMassFlow.'X_out[1]';
  volume.'ports[1]'.'Xi_outflow[1]' = pressureToMassFlow.'X_out[1]';
  volume.'ports[2]'.'Xi_outflow[1]' = pressureToMassFlow.'X_out[1]';
  volume.'ports[3]'.'Xi_outflow[1]' = pressureToMassFlow.'X_out[1]';
  volume.heatTransfer.'states[1]'.'X[1]' = pressureToMassFlow.'X_out[1]';
  volumeFlowRate1.port_b.'Xi_outflow[1]' = pressureToMassFlow.'X_out[1]';
  volume.medium.h = volumeFlowRate.port_a.h_outflow;
  volume.'ports[1]'.h_outflow = volumeFlowRate.port_a.h_outflow;
  volume.'ports[2]'.h_outflow = volumeFlowRate.port_a.h_outflow;
  volume.'ports[3]'.h_outflow = volumeFlowRate.port_a.h_outflow;
  volumeFlowRate1.port_b.h_outflow = volumeFlowRate.port_a.h_outflow;
  volume.'ports[1]'.p = volumeFlowRate.port_b.p;
  volume.'ports[3]'.p = volumeFlowRate.port_b.p;
  temperature.port.p = volumeFlowRate.port_b.p;
  volumeFlowRate1.port_b.m_flow = volume.'ports[2]'.m_flow;
  volumeFlowRate1.port_a.p = volume.'ports[2]'.p;
  pressure_source.medium.T = pressure_source.T_in;
  pressure_source.medium.state.T = pressure_source.T_in;
  pressure_source.medium.p = pressure_source.p_in;
  pressure_source.medium.state.p = pressure_source.p_in;
  pressure_source.'ports[1]'.p = pressure_source.p_in;
  volumeFlowRate.port_a.p = pressure_source.p_in;
  pressureToMassFlow.fluidPort.'C_outflow[1]' = pressureToMassFlow.'C_in[1]';
  volumeFlowRate1.port_a.'C_outflow[1]' = pressureToMassFlow.'C_in[1]';
  pressureToMassFlow.fluidPort.'Xi_outflow[1]' = pressureToMassFlow.'X_in[1]';
  pressureToMassFlow.fluidPort.p = pressureToMassFlow.p_in;
  volumeFlowRate1.port_b.p = pressureToMassFlow.p_in;
  volumeFlowRate.port_b.m_flow = pressure_source.'ports[1]'.m_flow;
  pressure_source.'ports[1]'.h_outflow = pressure_source.medium.h;
  volumeFlowRate.port_b.h_outflow = pressure_source.medium.h;
  volume.Hb_flow = volume._U_der;
  volume.mb_flow = volume._m_der;
  volume.'mbXi_flow[1]' = volume.'_mXi[1]_der';
  volume.'sum_ports_mXi_flow[1]' = volume.'_mXi[1]_der';
  volume.'sum_ports_mC_flow[1]' = volume.'mbC_flow[1]';
  volumeFlowRate.port_a.m_flow = volumeFlowRate.m_flow;
  volume.'ports[1]'.m_flow = volumeFlowRate.m_flow;
  volume.medium.state.'X[2]' = volume.medium.'X[2]';
  volume.heatTransfer.'states[1]'.'X[2]' = volume.medium.'X[2]';
  annotation (__Dymola_FMUImportVersion="Dymola 2021", __Dymola_FMUImportPath="C:/Users/FRICKL/Desktop/Modelon/Custom FMIs for INL/FMU/ComponentME.fmu", __Dymola_FMUImportIncludeAllVariables="true", __Dymola_FMUImportIntegrate="true", experiment(StartTime=0.0, StopTime=10.0, Tolerance=1E-08),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 ME")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = ComponentME</li>
<li>generationTool = Dymola Version 2019 FD01 (64-bit), 2018-10-10</li>
<li>generationDateAndTime = 2020-09-10T17:58:36Z</li>
</ul>
<p><br><b>Model Exchange Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>completedIntegratorStepNotNeeded = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = false</li>
<li>canGetAndSetFMUstate = true</li>
<li>canSerializeFMUstate = true</li>
<li>providesDirectionalDerivative = true</li>
</ul>
</html>"));
end ComponentME_fmu;
