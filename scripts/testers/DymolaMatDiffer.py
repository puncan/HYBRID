#Licensed under Apache 2.0 License.
#Â© 2020 Battelle Energy Alliance, LLC
#ALL RIGHTS RESERVED
#.
#Prepared by Battelle Energy Alliance, LLC
#Under Contract No. DE-AC07-05ID14517
#With the U. S. Department of Energy
#.
#NOTICE:  This computer software was prepared by Battelle Energy
#Alliance, LLC, hereinafter the Contractor, under Contract
#No. AC07-05ID14517 with the United States (U. S.) Department of
#Energy (DOE).  The Government is granted for itself and others acting on
#its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
#data to reproduce, prepare derivative works, and perform publicly and
#display publicly, by or on behalf of the Government. There is provision for
#the possible extension of the term of this license.  Subsequent to that
#period or any extension granted, the Government is granted for itself and
#others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide
#license in this data to reproduce, prepare derivative works, distribute
#copies to the public, perform publicly and display publicly, and to permit
#others to do so.  The specific term of the license can be identified by
#inquiry made to Contractor or DOE.  NEITHER THE UNITED STATES NOR THE UNITED
#STATES DEPARTMENT OF ENERGY, NOR CONTRACTOR MAKES ANY WARRANTY, EXPRESS OR
#IMPLIED, OR ASSUMES ANY LIABILITY OR RESPONSIBILITY FOR THE USE, ACCURACY,
#COMPLETENESS, OR USEFULNESS OR ANY INFORMATION, APPARATUS, PRODUCT, OR
#PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
#OWNED RIGHTS.
import os
import math
import scipy.io
import copy
import numpy as np
import pandas as pd

def find_nearest(array, value):
  """
    Find element in array nearest  to value
    @ In, array, numpy array
    @ In, value, the value
    @ Out, idx, int, index
    @ Out, diff[indx], flaat, the diff
  """
  array = np.asarray(array)
  diff =  np.abs(array - value)
  idx = (diff).argmin()
  return idx, diff[idx]

def find_nearest_array(array, array_comparison, tol = 1e-4):
  """
    Find nearest array
    @ In, array, array-like, the array to compare from
    @ In, array_comparison, array-like, the array to compare to
    @ In, tol, float, the tolerance
  """
  array_comparison = np.asarray(array_comparison)
  indeces = np.zeros(len(array), dtype=bool)
  notFound =  np.zeros(len(array), dtype=bool)
  for val in array_comparison:
    idx, diff = find_nearest(array, val)
    rel = (np.abs(diff / val)) if val != 0 else np.abs(val)
    if rel <= tol:
      indeces[idx] = True
    else:
      notFound[idx] = True

  return indeces, not np.any(notFound)



class DymolaMatDiffer:
  """
    DymolaMatDiffer is used for comparing mat files generated by Dymola
  """
  def __init__(self, testDir, outFile, **kwargs):

    """
      Create a DymolaMatDiffer class
      testDir: the directory where the test takes place
      outFile: the files to be compared.  They will be in testDir + outFile
               and testDir + gold + outFile
      kwargs: other arguments that may be included:
          - 'comment': indicates the character or string that should be used to denote a comment line
    """
    self.__outFile = outFile
    self.__messages = ""
    self.__same = True
    self.__rel_tol = float(kwargs.get('rel_tol',1e-13))
    self.__out_step = float(kwargs.get('outputStep',None))
    self.__stop_time = float(kwargs.get('stopTime',None))
    self.__testDir = testDir
    self.__goldDir = os.path.join(self.__testDir, "gold")
    self.variablesToLoad = []

  # Should be used to compare the gold file and the test file
  def diff(self):
    """
      Differ for Mat Files generated by Dymola
      @ In, None
      @ Out, (same, message), tuple, Is it the same, the message in case it is not
    """
    same = True
    message = ""
    #Test File Variables
    _vars = {}
    _blocks = []
    _namesData1 = []
    _namesData2 = []
    _timeSeriesData1 = []
    _timeSeriesData2 = []

    #Gold File Variables
    _varsgold = {}
    _blocksgold = []
    _namesData1gold = []
    _namesData2gold = []
    _timeSeriesData1gold = []
    _timeSeriesData2gold = []

    # Load the output file (.mat file) that have been generated by running Dymola executable and
    mat = scipy.io.loadmat(os.path.join(self.__testDir, self.__outFile), chars_as_strings=False)
    matgold = scipy.io.loadmat(os.path.join(self.__goldDir,self.__outFile), chars_as_strings=False)
    # Define the functions that extract strings from the matrix:
    #  - strMatNormal: for parallel string
    #  - strMatTrans:  for vertical string
    # These functions join the strings together, resulting in one string in each row, and remove
    #   trailing whitespace.
    strMatNormal = lambda a: [''.join(s).rstrip() for s in a]
    strMatTrans = lambda a: [''.join(s).rstrip() for s in zip(*a)]

    # Define the function that returns '1.0' with the sign of 'x'
    sign = lambda x: math.copysign(1.0, x)

    # Check the structure of the output file.
    try:
      fileInfo = strMatNormal(mat['Aclass'])
    except KeyError:
      same, message = False, 'File structure not supported!'
      return same, message
    # Check the version of the output file (version 1.1).
    if fileInfo[1] != '1.1' or fileInfo[3] != 'binTrans':
      same, message = False, 'File structure not supported!'
      return same, message
    if same:
      names = strMatTrans(mat['name'])  # names
      namesgold = strMatTrans(matgold['name'])  # names Gold File
      descr = strMatTrans(mat['description'])  # descriptions
      descrgold = strMatTrans(matgold['description'])  # descriptions Gold File
      for i in range(len(names)):
        d = mat['dataInfo'][0][i]  # data block
        x = mat['dataInfo'][1][i]  # column (original)
        c = abs(x) - 1  # column (reduced)
        s = sign(x)  # sign
        if c:
          _vars[names[i]] = (descr[i], d, c, float(s))
          if not d in _blocks:
            _blocks.append(d)
        else:
          _absc = (names[i], descr[i])

      for i in range(len(namesgold)):    #Gold File
        d = matgold['dataInfo'][0][i]  # data block
        x = matgold['dataInfo'][1][i]  # column (original)
        c = abs(x) - 1  # column (reduced)
        s = sign(x)  # sign
        if c:
          _varsgold[namesgold[i]] = (descrgold[i], d, c, float(s))
          if not d in _blocks:
            _blocksgold.append(d)
        else:
          _abscgold = (namesgold[i], descrgold[i])
      # Extract the trajectory for the variable 'Time' and store the data in the variable 'timeSteps'.
      timeSteps = mat['data_2'][0]
      timeStepsgold = matgold['data_2'][0]
      if self.__stop_time and self.__out_step:

        numComparisonPts = int(self.__stop_time/self.__out_step)+ 1
        comparisonTimeGrid = np.linspace(timeStepsgold[0], timeStepsgold[-1], num=numComparisonPts, endpoint=True)
        indicesSim, allFound = find_nearest_array(timeSteps, comparisonTimeGrid, tol=self.__rel_tol)
        if not allFound:
          print("ERROR: Not all the time steps have been found in the simulation file.")
          print("     : Simulation Time Steps")
          for tm in timeSteps:
            print(tm)
          print("     : Comparison Time Steps")
          for tm in comparisonTimeGrid:
            print(tm)
          raise IOError("Not all the time steps have been found in the simulation file. Check the input of the model. SEE ABOVE!")
        indicesGold, allFound = find_nearest_array(timeStepsgold, comparisonTimeGrid, tol=self.__rel_tol)
        if not allFound:
          raise IOError("Not all the time steps have been found in the gold file. Check the input of the model.SEE ABOVE!")
      # Compute the number of output points of trajectory (time series data).
      numOutputPts = timeSteps.shape[0]
      numOutputPtsgold = timeStepsgold.shape[0]
      # Convert the variable type of 'timeSteps' from '1-d array' to '2-d array'.
      if not self.__out_step:
        timeStepsArray, timeStepsArraygold = np.array([timeSteps]),  np.array([timeStepsgold])
      else:
        timeStepsArray, timeStepsArraygold = np.array([comparisonTimeGrid]),  np.array([comparisonTimeGrid])
      # Extract the names and output points of all variables and store them in the variables:
      #  - _namesData1: Names of parameters
      #  - _namesData2: Names of the variables that are not parameters
      #  - _timeSeriesData1: Trajectories (time series data) of '_namesData1'
      #  - _timeSeriesData2: Trajectories (time series data) of '_namesData2'
      for (k, v) in _vars.items():
        readIt = True
        if len(self.variablesToLoad) > 0 and k not in self.variablesToLoad:
          readIt = False
        if readIt:
          dataValue = mat['data_%d' % (v[1])][v[2]]
          if v[3] < 0:
            dataValue = dataValue * -1.0
          if v[1] == 1:
            _namesData1.append(k)
            _timeSeriesData1.append(dataValue)
          elif v[1] == 2:
            _namesData2.append(k)
            _timeSeriesData2.append(dataValue)
          else:
            same, message = False, 'File structure not supported!'
            return same, message
      timeSeriesData1,timeSeriesData2 = np.array(_timeSeriesData1), np.array(_timeSeriesData2)
      for (k, v) in _varsgold.items():
        readIt = True
        if len(self.variablesToLoad) > 0 and k not in self.variablesToLoad:
          readIt = False
        if readIt:
          dataValue = matgold['data_%d' % (v[1])][v[2]]
          if v[3] < 0:
            dataValue = dataValue * -1.0
          if v[1] == 1:
            _namesData1gold.append(k)
            _timeSeriesData1gold.append(dataValue)
          elif v[1] == 2:
            _namesData2gold.append(k)
            _timeSeriesData2gold.append(dataValue)
          else:
            same, message = False, 'File structure not supported!'
            return same, message
      timeSeriesData1gold, timeSeriesData2gold = np.array(_timeSeriesData1gold), np.array(_timeSeriesData2gold)
      # Recombine the names of the variables and insert the variable 'Time'.
      # Order of the variable names should be 'Time', _namesData1, _namesData2.
      # Also, convert the type of the resulting variable from 'list' to '2-d array'.
      varNames = np.array([[_absc[0]] + _namesData1 + _namesData2])
      varNamesgold = np.array([[_abscgold[0]] + _namesData1gold + _namesData2gold])
      # Compute the number of parameters.
      sizeParams = timeSeriesData1.shape[0]
      sizeParamsgold = timeSeriesData1gold.shape[0]
      # Create a 2-d array whose size is 'the number of parameters' by 'number of ouput points of the trajectories'.
      # Fill each row in a 2-d array with the parameter value.
      Data1Array = np.full((sizeParams, numOutputPts), 1.)
      for n in range(sizeParams):
        Data1Array[n, :] = timeSeriesData1[n, 0]
      Data1Arraygold = np.full((sizeParamsgold, numOutputPtsgold), 1.)
      for n in range(sizeParamsgold):
        Data1Arraygold[n, :] = timeSeriesData1gold[n, 0]
      # Create an array of trajectories, which are to be written to CSV file.
      varTrajectories = np.matrix.transpose(np.concatenate((timeStepsArray, Data1Array, timeSeriesData2), axis=0))
      varTrajectoriesgold = np.matrix.transpose(np.concatenate((timeStepsArraygold, Data1Arraygold, timeSeriesData2gold), axis=0))
      if self.__out_step:
        varTrajectories =  varTrajectories[indicesSim, :]
        varTrajectoriesgold =  varTrajectoriesgold[indicesGold, :]
      df = pd.DataFrame(data=varTrajectories, columns=varNames.flatten().tolist()).sort_index(axis=1)
      dfGold = pd.DataFrame(data=varTrajectoriesgold, columns=varNamesgold.flatten().tolist()).sort_index(axis=1)
      varTrajectoriesgold =  dfGold.values
      varTrajectories =  df.values
      #Basically here is the area where all the comparisons can be made.
      # #######Test if they have the same size####
      if df.shape == dfGold.shape:
        if not df.columns.equals(dfGold.columns):
          print('\n Variable Names have Changed!')
          diffVariables2 =  dfGold.columns[dfGold.columns != df.columns].tolist()
          same, message = False, 'Variable Names are different. Variables not present in reference files are: \n' + ' '.join(diffVariables2)
        else:
          # Test if they are within a certain tolerance of each other
          diffMatrix = df.subtract(dfGold).abs()
          diffMatrix.fillna(0.0, inplace=True)
          relativeDf = diffMatrix.div(dfGold)
          relativeDf.fillna(0.0, inplace=True)
          relativeDf = relativeDf.abs()
          maxValues = relativeDf.max().to_frame().T.values.flatten()
          mask =  np.where(maxValues > self.__rel_tol)
          diffVariables = relativeDf.columns[mask]
          maxValues = maxValues[mask]
          if len(maxValues):
            maxValues = maxValues.flatten().tolist()
            diffVariables =  diffVariables.tolist()
            if len(diffVariables):
              res =  "\nMax_Rel_Diff  Variable\n"
              res += "\n".join("{:.10f}  {} ".format(x, y) for x, y in zip(maxValues, diffVariables))
              same, message = False, 'Variable Values are different. Variables that are different (with their max relative difference, respectevely) are: \n' + res
      else:
        same, message = False, 'Shapes of the Values do not match!'
    return (same, message)
